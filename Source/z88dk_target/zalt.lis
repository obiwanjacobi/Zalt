1     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2     0000              ; SELECT CRT0 FROM -STARTUP=N COMMANDLINE OPTION ;;;;;;;;;;;;;;
3     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4     0000              
5     0000              INCLUDE "zcc_opt.def"
1     0000              
2     0000              IF !DEFINED_Z88DK_USES_SDCC
3     0000              	defc	DEFINED_Z88DK_USES_SDCC = 1
4     0000              	defc Z88DK_USES_SDCC = 1
5     0000              	IFNDEF Z88DK_USES_SDCC
6     0000              	ENDIF
7     0000              ENDIF
8     0000              
9     0000              
6     0000              
7     0000              IFNDEF startup
8     0000              
9     0000                 ; startup undefined so select a default
10    0000              
11    0000                 defc startup = 0
12    0000              
13    0000              ENDIF
14    0000              
15    0000              
16    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
17    0000              ;; user supplied crt ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
18    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
19    0000              
20    0000              IF startup = -1
21    0000              
22    0000                 INCLUDE "crt.asm"
23    0000              
24    0000              ENDIF
25    0000              
26    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
27    0000              ;; ram model ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
28    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
29    0000              
30    0000              IF startup = 0
31    0000              
32    0000                 ; generic zalt startup
33    0000              
34    0000                 IFNDEF __CRTDEF
35    0000              
36    0000                    defc __CRTDEF = 0
37    0000              
38    0000                 ENDIF
39    0000              
40    0000                 IFNDEF __MMAP
41    0000              
42    0000                    defc __MMAP = 0
43    0000              
44    0000                 ENDIF
45    0000              
46    0000                 INCLUDE "startup/zalt_crt_0.asm"
1     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2     0000              ;;                  zalt standalone target                   ;;
3     0000              ;;    generated by target/zalt/startup/zalt_crt_0.asm.m4     ;;
4     0000              ;;                                                           ;;
5     0000              ;;                  flat 64k address space*                  ;;
6     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
7     0000              ; *) for now
8     0000              
9     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
10    0000              ;; CRT AND CLIB CONFIGURATION ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
11    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
12    0000              
13    0000              include "../crt_defaults.inc"
1     0000              
2     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
3     0000              ;; crt defaults ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
5     0000              
6     0000                 ; crt configuration
7     0000              
8     0000                 defc DEF__crt_org_code              = 0       ;; org of code section
9     0000                 defc DEF__crt_org_data              = 0       ;; org of data section (0 or -1 means follow code, -1 means generate separate binary)
10    0000                 defc DEF__crt_org_bss               = 0       ;; org of bss section (0 or -1 means follow data, -1 means generate separate binary)
11    0000              
12    0000                 defc DEF__crt_model                 = 0       ;; 0 = ram model, 1 = rom model, 2 = compressed rom model
13    0000              
14    0000                 defc DEF__register_sp               = 0       ;; initial value of sp (-1 = do not modify (some targets may redefine meaning), 0 = top of memory)
15    0000                 defc DEF__crt_stack_size            = 512     ;; minimum size reserved for stack when automatically allocating memory for the malloc heap
16    0000              
17    0000                 defc DEF__crt_initialize_bss        = 0       ;; generate code to initialize bss section at startup (only applicable if ram model in use)
18    0000              
19    0000                 defc DEF__crt_include_preamble      = 0       ;; if non-zero, user supplies code in file "crt_preamble.asm" that is inserted at the start of the binary
20    0000              
21    0000                 defc DEF__crt_enable_streams        = 0x7     ;; set bit enables stream, stdin/stdout/stderr enabled
22    0000              
23    0000                 defc DEF__crt_enable_commandline    = 2       ;; generate argc and argv from command line (targets without command line will get argc=1, argv[0]="", argv[1]=NULL)
24    0000                 defc DEF__crt_enable_restart        = 0       ;; if non-zero, restart the program on exit (correct initialization of static variables with rom models only)
25    0000                 defc DEF__crt_enable_close          = 1       ;; if non-zero, close files on exit
26    0000              
27    0000                 defc DEF__crt_enable_eidi           = 0       ;; bit flags: 0x01 = di on restart, 0x02 = ei on restart, 0x10 = di on exit, 0x20 = ei on exit
28    0000                 defc DEF__crt_on_exit               = 0x10001 ;; halt on exit (see documentation for other exit behaviours)
29    0000              
30    0000                 defc DEF__crt_enable_rst            = 0       ;; if non-zero and in some crts with code org = 0, set bits indicate which rst locations are implemented with user code
31    0000                 defc DEF__crt_enable_nmi            = 0       ;; if non-zero and in some crts with code org = 0, a jump to user code to service the nmi is inserted
32    0000              
33    0000                 ; clib defaults
34    0000              
35    0000                 defc DEF__clib_exit_stack_size      = 32      ;; max number of functions that can be registered with atexit()
36    0000                 defc DEF__clib_quickexit_stack_size = 32      ;; max number of functions that can be registered with at_quickexit()
37    0000              
38    0000                 defc DEF__clib_malloc_heap_size     = -1      ;; size of malloc heap (0 = do not create a heap, -1 = automatically place heap between end of bss section and bottom of stack)
39    0000                 defc DEF__clib_stdio_heap_size      = 256     ;; size of stdio heap (0 = do not allocate bytes for opening of files)
40    0000              
41    0000                 defc DEF__clib_balloc_table_size    = 0       ;; number of queues created for balloc block memory allocator
42    0000              
43    0000                 defc DEF__clib_fopen_max            = 8       ;; max number of FILE* (-1 = do not create list of open FILE* (only effective if no stdin/stdout/stderr))
44    0000                 defc DEF__clib_open_max             = 8       ;; max number of open files
45    0000              
46    0000              ;; end crt defaults ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
47    0000              
14    0000              include "crt_target_defaults.inc"
1     0000              
2     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
3     0000              ;; crt target defaults ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
5     0000              
6     0000              IF __CRTDEF = -1
7     0000              
8     0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
9     0000                 ;; user supplied crt defaults ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
10    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
11    0000              
12    0000                 INCLUDE "crtdef.inc"
13    0000              
14    0000              ENDIF
15    0000              
16    0000              IF __CRTDEF = 0
17    0000              
18    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
19    0000                 ;; zalt ram model ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
20    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
21    0000              
22    0000                 defc TAR__crt_org_code              = 0 ; was 32768!
23    0000                 defc TAR__crt_org_data              = 0
24    0000                 defc TAR__crt_org_bss               = 0
25    0000              
26    0000                 defc TAR__crt_model                 = 0
27    0000              
28    0000                 defc TAR__register_sp               = 0
29    0000                 defc TAR__crt_stack_size            = 512
30    0000              
31    0000                 defc TAR__crt_initialize_bss        = 0
32    0000              
33    0000                 defc TAR__crt_enable_commandline    = 0
34    0000                 defc TAR__crt_enable_restart        = 0
35    0000                 defc TAR__crt_enable_close          = 1
36    0000              
37    0000                 defc TAR__crt_enable_rst            = 0
38    0000                 defc TAR__crt_enable_nmi            = 0
39    0000              
40    0000                 ; clib defaults
41    0000              
42    0000                 defc TAR__clib_exit_stack_size      = 2
43    0000                 defc TAR__clib_quickexit_stack_size = 0
44    0000              
45    0000                 defc TAR__clib_malloc_heap_size     = -1
46    0000                 defc TAR__clib_stdio_heap_size      = 128
47    0000              
48    0000                 defc TAR__clib_balloc_table_size    = 0
49    0000              
50    0000                 defc TAR__clib_fopen_max            = 0
51    0000                 defc TAR__clib_open_max             = 0
52    0000              
53    0000              ENDIF
54    0000              
55    0000              ;; end crt target defaults ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
56    0000              
15    0000              include "../crt_rules.inc"
1     0000              
2     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
3     0000              ;; crt rules ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
5     0000              
6     0000              
7     0000                 IFDEF myzorg
8     0000              
9     0000                    defc __crt_org_code = myzorg
10    0000              
11    0000                 ELSE
12    0000              
13    0000                    IFDEF CRT_ORG_CODE
14    0000              
15    0000                       defc __crt_org_code = CRT_ORG_CODE
16    0000              
17    0000                    ELSE
18    0000              
19    0000                       IFDEF TAR__crt_org_code
20    0000              
21    0000                          defc __crt_org_code = TAR__crt_org_code
22    0000              
23    0000                       ELSE
24    0000              
25    0000                          defc __crt_org_code = DEF__crt_org_code
26    0000              
27    0000                       ENDIF
28    0000              
29    0000                    ENDIF
30    0000              
31    0000                    defc myzorg = __crt_org_code
32    0000              
33    0000                 ENDIF
34    0000              
35    0000              
36    0000                 IFDEF REGISTER_SP
37    0000              
38    0000                    defc __register_sp = REGISTER_SP
39    0000              
40    0000                 ELSE
41    0000              
42    0000                    IFDEF STACKPTR
43    0000              
44    0000                       defc __register_sp = STACKPTR
45    0000              
46    0000                    ELSE
47    0000              
48    0000                       IFDEF TAR__register_sp
49    0000              
50    0000                          defc __register_sp = TAR__register_sp
51    0000              
52    0000                       ELSE
53    0000              
54    0000                          defc __register_sp = DEF__register_sp
55    0000              
56    0000                       ENDIF
57    0000              
58    0000                    ENDIF
59    0000              
60    0000                 ENDIF
61    0000              
62    0000              
63    0000                 IFDEF CRT_STACK_SIZE
64    0000              
65    0000                    defc __crt_stack_size = CRT_STACK_SIZE
66    0000              
67    0000                 ELSE
68    0000              
69    0000                    IFDEF TAR__crt_stack_size
70    0000              
71    0000                       defc __crt_stack_size = TAR__crt_stack_size
72    0000              
73    0000                    ELSE
74    0000              
75    0000                       defc __crt_stack_size = DEF__crt_stack_size
76    0000              
77    0000                    ENDIF
78    0000              
79    0000                 ENDIF
80    0000              
81    0000              
82    0000                 IFDEF CRT_ORG_DATA
83    0000              
84    0000                    defc __crt_org_data = CRT_ORG_DATA
85    0000              
86    0000                 ELSE
87    0000              
88    0000                    IFDEF TAR__crt_org_data
89    0000              
90    0000                       defc __crt_org_data = TAR__crt_org_data
91    0000              
92    0000                    ELSE
93    0000              
94    0000                       defc __crt_org_data = DEF__crt_org_data
95    0000              
96    0000                    ENDIF
97    0000              
98    0000                 ENDIF
99    0000              
100   0000              
101   0000                 IFDEF CRT_ORG_BSS
102   0000              
103   0000                    defc __crt_org_bss = CRT_ORG_BSS
104   0000              
105   0000                 ELSE
106   0000              
107   0000                    IFDEF TAR__crt_org_bss
108   0000              
109   0000                       defc __crt_org_bss = TAR__crt_org_bss
110   0000              
111   0000                    ELSE
112   0000              
113   0000                       defc __crt_org_bss = DEF__crt_org_bss
114   0000              
115   0000                    ENDIF
116   0000              
117   0000                 ENDIF
118   0000              
119   0000              
120   0000                 IFDEF CRT_MODEL
121   0000              
122   0000                    defc __crt_model = CRT_MODEL
123   0000              
124   0000                 ELSE
125   0000              
126   0000                    IFDEF TAR__crt_model
127   0000              
128   0000                       defc __crt_model = TAR__crt_model
129   0000              
130   0000                    ELSE
131   0000              
132   0000                       defc __crt_model = DEF__crt_model
133   0000              
134   0000                    ENDIF
135   0000              
136   0000                 ENDIF
137   0000              
138   0000              
139   0000                 IFDEF CRT_INITIALIZE_BSS
140   0000              
141   0000                    defc __crt_initialize_bss = CRT_INITIALIZE_BSS
142   0000              
143   0000                 ELSE
144   0000              
145   0000                    IFDEF TAR__crt_initialize_bss
146   0000              
147   0000                       defc __crt_initialize_bss = TAR__crt_initialize_bss
148   0000              
149   0000                    ELSE
150   0000              
151   0000                       defc __crt_initialize_bss = DEF__crt_initialize_bss
152   0000              
153   0000                    ENDIF
154   0000              
155   0000                 ENDIF
156   0000              
157   0000              
158   0000                 IFDEF CRT_INCLUDE_PREAMBLE
159   0000              
160   0000                    defc __crt_include_preamble = CRT_INCLUDE_PREAMBLE
161   0000              
162   0000                 ELSE
163   0000              
164   0000                    IFDEF TAR__crt_include_preamble
165   0000              
166   0000                       defc __crt_include_preamble = TAR__crt_include_preamble
167   0000              
168   0000                    ELSE
169   0000              
170   0000                       defc __crt_include_preamble = DEF__crt_include_preamble
171   0000              
172   0000                    ENDIF
173   0000              
174   0000                 ENDIF
175   0000              
176   0000              
177   0000                 IFDEF CRT_ENABLE_STREAMS
178   0000              
179   0000                    defc __crt_enable_streams = CRT_ENABLE_STREAMS
180   0000              
181   0000                 ELSE
182   0000              
183   0000                    IFDEF TAR__crt_enable_streams
184   0000              
185   0000                       defc __crt_enable_streams = TAR__crt_enable_streams
186   0000              
187   0000                    ELSE
188   0000              
189   0000                       defc __crt_enable_streams = DEF__crt_enable_streams
190   0000              
191   0000                    ENDIF
192   0000              
193   0000                 ENDIF
194   0000              
195   0000              
196   0000                 IFDEF CRT_ENABLE_COMMANDLINE
197   0000              
198   0000                    defc __crt_enable_commandline = CRT_ENABLE_COMMANDLINE
199   0000              
200   0000                 ELSE
201   0000              
202   0000                    IFDEF TAR__crt_enable_commandline
203   0000              
204   0000                       defc __crt_enable_commandline = TAR__crt_enable_commandline
205   0000              
206   0000                    ELSE
207   0000              
208   0000                       defc __crt_enable_commandline = DEF__crt_enable_commandline
209   0000              
210   0000                    ENDIF
211   0000              
212   0000                 ENDIF
213   0000              
214   0000              
215   0000                 IFDEF CRT_ENABLE_RESTART
216   0000              
217   0000                    defc __crt_enable_restart = CRT_ENABLE_RESTART
218   0000              
219   0000                 ELSE
220   0000              
221   0000                    IFDEF TAR__crt_enable_restart
222   0000              
223   0000                       defc __crt_enable_restart = TAR__crt_enable_restart
224   0000              
225   0000                    ELSE
226   0000              
227   0000                       defc __crt_enable_restart = DEF__crt_enable_restart
228   0000              
229   0000                    ENDIF
230   0000              
231   0000                 ENDIF
232   0000              
233   0000              
234   0000                 IFDEF CRT_ENABLE_CLOSE
235   0000              
236   0000                    defc __crt_enable_close = CRT_ENABLE_CLOSE
237   0000              
238   0000                 ELSE
239   0000              
240   0000                    IFDEF TAR__crt_enable_close
241   0000              
242   0000                       defc __crt_enable_close = TAR__crt_enable_close
243   0000              
244   0000                    ELSE
245   0000              
246   0000                       defc __crt_enable_close = DEF__crt_enable_close
247   0000              
248   0000                    ENDIF
249   0000              
250   0000                 ENDIF
251   0000              
252   0000              
253   0000                 IFDEF CRT_ENABLE_EIDI
254   0000              
255   0000                    defc __crt_enable_eidi = CRT_ENABLE_EIDI
256   0000              
257   0000                 ELSE
258   0000              
259   0000                    IFDEF TAR__crt_enable_eidi
260   0000              
261   0000                       defc __crt_enable_eidi = TAR__crt_enable_eidi
262   0000              
263   0000                    ELSE
264   0000              
265   0000                       defc __crt_enable_eidi = DEF__crt_enable_eidi
266   0000              
267   0000                    ENDIF
268   0000              
269   0000                 ENDIF
270   0000              
271   0000              
272   0000                 IF __crt_enable_restart
273   0000              
274   0000                    defc __crt_on_exit = 0x10008
275   0000              
276   0000                 ELSE
277   0000              
278   0000                    IFDEF CRT_ON_EXIT
279   0000              
280   0000                       defc __crt_on_exit = CRT_ON_EXIT
281   0000              
282   0000                    ELSE
283   0000              
284   0000                       IFDEF TAR__crt_on_exit
285   0000              
286   0000                          defc __crt_on_exit = TAR__crt_on_exit
287   0000              
288   0000                       ELSE
289   0000              
290   0000                          defc __crt_on_exit = DEF__crt_on_exit
291   0000              
292   0000                       ENDIF
293   0000              
294   0000                    ENDIF
295   0000              
296   0000                 ENDIF
297   0000              
298   0000              
299   0000                 IFDEF CLIB_EXIT_STACK_SIZE
300   0000              
301   0000                    defc __clib_exit_stack_size = CLIB_EXIT_STACK_SIZE
302   0000              
303   0000                 ELSE
304   0000              
305   0000                    IFDEF TAR__clib_exit_stack_size
306   0000              
307   0000                       defc __clib_exit_stack_size = TAR__clib_exit_stack_size
308   0000              
309   0000                    ELSE
310   0000              
311   0000                       defc __clib_exit_stack_size = DEF__clib_exit_stack_size
312   0000              
313   0000                    ENDIF
314   0000              
315   0000                 ENDIF
316   0000              
317   0000              
318   0000                 IFDEF CLIB_QUICKEXIT_STACK_SIZE
319   0000              
320   0000                    defc __clib_quickexit_stack_size = CLIB_QUICKEXIT_STACK_SIZE
321   0000              
322   0000                 ELSE
323   0000              
324   0000                    IFDEF TAR__clib_quickexit_stack_size
325   0000              
326   0000                       defc __clib_quickexit_stack_size = TAR__clib_quickexit_stack_size
327   0000              
328   0000                    ELSE
329   0000              
330   0000                       defc __clib_quickexit_stack_size = DEF__clib_quickexit_stack_size
331   0000              
332   0000                    ENDIF
333   0000              
334   0000                 ENDIF
335   0000              
336   0000              
337   0000                 IFDEF CLIB_MALLOC_HEAP_SIZE
338   0000              
339   0000                    defc __clib_malloc_heap_size = CLIB_MALLOC_HEAP_SIZE
340   0000              
341   0000                 ELSE
342   0000              
343   0000                    IFDEF TAR__clib_malloc_heap_size
344   0000              
345   0000                       defc __clib_malloc_heap_size = TAR__clib_malloc_heap_size
346   0000              
347   0000                    ELSE
348   0000              
349   0000                       defc __clib_malloc_heap_size = DEF__clib_malloc_heap_size
350   0000              
351   0000                    ENDIF
352   0000              
353   0000                 ENDIF
354   0000              
355   0000              
356   0000                 IFDEF CLIB_STDIO_HEAP_SIZE
357   0000              
358   0000                    defc __clib_stdio_heap_size = CLIB_STDIO_HEAP_SIZE
359   0000              
360   0000                 ELSE
361   0000              
362   0000                    IFDEF TAR__clib_stdio_heap_size
363   0000              
364   0000                       defc __clib_stdio_heap_size = TAR__clib_stdio_heap_size
365   0000              
366   0000                    ELSE
367   0000              
368   0000                       defc __clib_stdio_heap_size = DEF__clib_stdio_heap_size
369   0000              
370   0000                    ENDIF
371   0000              
372   0000                 ENDIF
373   0000              
374   0000              
375   0000                 IFDEF CLIB_BALLOC_TABLE_SIZE
376   0000              
377   0000                    defc __clib_balloc_table_size = CLIB_BALLOC_TABLE_SIZE
378   0000              
379   0000                 ELSE
380   0000              
381   0000                    IFDEF TAR__clib_balloc_table_size
382   0000              
383   0000                       defc __clib_balloc_table_size = TAR__clib_balloc_table_size
384   0000              
385   0000                    ELSE
386   0000              
387   0000                       defc __clib_balloc_table_size = DEF__clib_balloc_table_size
388   0000              
389   0000                    ENDIF
390   0000              
391   0000                 ENDIF
392   0000              
393   0000              
394   0000                 IFDEF CLIB_FOPEN_MAX
395   0000              
396   0000                    defc __clib_fopen_max = CLIB_FOPEN_MAX
397   0000              
398   0000                 ELSE
399   0000              
400   0000                    IFDEF TAR__clib_fopen_max
401   0000              
402   0000                       defc __clib_fopen_max = TAR__clib_fopen_max
403   0000              
404   0000                    ELSE
405   0000              
406   0000                       defc __clib_fopen_max = DEF__clib_fopen_max
407   0000              
408   0000                    ENDIF
409   0000              
410   0000                 ENDIF
411   0000              
412   0000              
413   0000                 IFDEF CLIB_OPEN_MAX
414   0000              
415   0000                    defc __clib_open_max = CLIB_OPEN_MAX
416   0000              
417   0000                 ELSE
418   0000              
419   0000                    IFDEF TAR__clib_open_max
420   0000              
421   0000                       defc __clib_open_max = TAR__clib_open_max
422   0000              
423   0000                    ELSE
424   0000              
425   0000                       defc __clib_open_max = DEF__clib_open_max
426   0000              
427   0000                    ENDIF
428   0000              
429   0000                 ENDIF
430   0000              
431   0000              
432   0000                 IFDEF CRT_ENABLE_RST
433   0000              
434   0000                    defc __crt_enable_rst = CRT_ENABLE_RST
435   0000              
436   0000                 ELSE
437   0000              
438   0000                    IFDEF TAR__crt_enable_rst
439   0000              
440   0000                       defc __crt_enable_rst = TAR__crt_enable_rst
441   0000              
442   0000                    ELSE
443   0000              
444   0000                       defc __crt_enable_rst = DEF__crt_enable_rst
445   0000              
446   0000                    ENDIF
447   0000              
448   0000                 ENDIF
449   0000              
450   0000              
451   0000                 IFDEF CRT_ENABLE_NMI
452   0000              
453   0000                    defc __crt_enable_nmi = CRT_ENABLE_NMI
454   0000              
455   0000                 ELSE
456   0000              
457   0000                    IFDEF TAR__crt_enable_nmi
458   0000              
459   0000                       defc __crt_enable_nmi = TAR__crt_enable_nmi
460   0000              
461   0000                    ELSE
462   0000              
463   0000                       defc __crt_enable_nmi = DEF__crt_enable_nmi
464   0000              
465   0000                    ENDIF
466   0000              
467   0000                 ENDIF
468   0000              
469   0000              
470   0000                 ;; public definitions
471   0000              
472   0000                 PUBLIC __exit_stack_size
473   0000                 PUBLIC __quickexit_stack_size
474   0000              
475   0000                 defc __exit_stack_size = __clib_exit_stack_size
476   0000                 defc __quickexit_stack_size = __clib_quickexit_stack_size
477   0000              
478   0000              ;; end crt rules ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
479   0000              
16    0000              
17    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
18    0000              ;; SET UP MEMORY MODEL ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
19    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
20    0000              
21    0000              include "memory_model.inc"
1     0000              
2     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
3     0000              ;; memory model ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
5     0000              
6     0000              IF __MMAP = -1
7     0000              
8     0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
9     0000                 ;; user supplied memory map ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
10    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
11    0000              
12    0000                 INCLUDE "mmap.inc"
13    0000              
14    0000              ENDIF
15    0000              
16    0000              IF __MMAP = 0
17    0000              
18    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
19    0000                 ;; standard CODE/DATA/BSS memory map ;;;;;;;;;;;;;;;;;;;;;;;
20    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
21    0000              
22    0000                 ;;INCLUDE "../crt_memory_model.inc"
23    0000              
24    0000              
25    0000              
26    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
27    0000              ;; memory model ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
28    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
29    0000              
30    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
31    0000              
32    0000              SECTION CODE
33    0000              
34    0000              org __crt_org_code
35    0000              
36    0000              section code_crt_init
37    0000              section code_crt_main
38    0000              section code_crt_exit
39    0000              section code_crt_return
40    0000              section code_crt_common
41    0000              
42    0000              ; zalt
43    0000              section zalt_system
44    0000              section zalt_lib
45    0000              section zalt_debug
46    0000              
47    0000              section code_driver
48    0000              section code_font
49    0000              section code_clib
50    0000                include "../../clib_code.inc"
1     0000              
2     0000              ;; clib code segments ;;;;;;;;;
3     0000              
4     0000              section code_adt_b_array
5     0000              section code_adt_b_vector
6     0000              section code_adt_ba_priority_queue
7     0000              section code_adt_ba_stack
8     0000              section code_adt_bv_priority_queue
9     0000              section code_adt_bv_stack
10    0000              section code_adt_p_forward_list
11    0000              section code_adt_p_forward_list_alt
12    0000              section code_adt_p_list
13    0000              section code_adt_p_queue
14    0000              section code_adt_p_stack
15    0000              section code_adt_w_array
16    0000              section code_adt_w_vector
17    0000              section code_adt_wa_priority_queue
18    0000              section code_adt_wa_stack
19    0000              section code_adt_wv_priority_queue
20    0000              section code_adt_wv_stack
21    0000              section code_alloc_balloc
22    0000              section code_alloc_malloc
23    0000              section code_alloc_obstack
24    0000              section code_arch
25    0000              section code_bifrost_h
26    0000              section code_bifrost_l
27    0000              section code_bifrost2
28    0000              section code_compress_aplib
29    0000              section code_compress_zx7
30    0000              section code_ctype
31    0000              section code_driver_general
32    0000              section code_driver_character_input
33    0000              section code_driver_character_output
34    0000              section code_driver_memstream
35    0000              section code_driver_terminal_input
36    0000              section code_driver_terminal_output
37    0000              section code_driver_tty
38    0000              section code_error
39    0000              section code_fcntl
40    0000              section code_font_fzx
41    0000              section code_fp_genmath
42    0000              section code_fp_math48
43    0000              section code_input
44    0000              section code_inttypes
45    0000              section code_l
46    0000              section code_l_sccz80
47    0000              section code_l_sdcc
48    0000              section code_locale
49    0000              section code_math
50    0000              section code_network
51    0000              section code_nirvanam
52    0000              section code_nirvanap
53    0000              section code_setjmp
54    0000              section code_sound_bit
55    0000              section code_stdio
56    0000              section code_stdlib
57    0000              section code_string
58    0000              section code_temp_sp1
59    0000              section code_threads
60    0000              section code_threads_mutex
61    0000              section code_z80
62    0000              
63    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
64    0000              
51    0000              section code_lib
52    0000              section code_compiler
53    0000              section code_user
54    0000              
55    0000              section rodata_driver
56    0000              section rodata_font
57    0000              section rodata_clib
58    0000                include "../../clib_rodata.inc"
1     0000              
2     0000              ;; clib rodata segments ;;;;;;;
3     0000              
4     0000              section rodata_error_strings
5     0000              section rodata_error_string_end
6     0000  00          defb 0
7     0001              section rodata_fcntl
8     0000              section rodata_font_4x8
9     0000              section rodata_font_8x8
10    0000              section rodata_font_fzx
11    0000              section rodata_input
12    0000              section rodata_sound_bit
13    0000              section rodata_stdio
14    0000              section rodata_stdlib
15    0000              
16    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
17    0000              
59    0000                ;;section rodata_error_strings
60    0000                ;;section rodata_error_string_end
61    0000                ;;defb 0
62    0000              section rodata_lib
63    0000              section rodata_compiler
64    0000              section rodata_user
65    0000              
66    0000              SECTION CODE_END
67    0000              
68    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
69    0000              
70    0000              SECTION DATA
71    0000              
72    0000              IF __crt_org_data
73    0000              
74    0000                 org __crt_org_data
75    0000              
76    0000              ELSE
77    0000              
78    0000                 IF __crt_model
79    0000              
80    0000                    "DATA section address must be specified for rom models"
81    0000              
82    0000                 ENDIF
83    0000              
84    0000              ENDIF
85    0000              
86    0000  00          defb 0
87    0001              
88    0001              section smc_driver
89    0000              section smc_font
90    0000              section smc_clib
91    0000                include "../../clib_smc.inc"
1     0000              
2     0000              ;; clib self-modifying code ;;;
3     0000              
4     0000              section smc_fcntl
5     0000              section smc_l
6     0000              section smc_sound_bit
7     0000              
8     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
9     0000              
92    0000              section smc_lib
93    0000              section smc_compiler
94    0000              section smc_user
95    0000              
96    0000              section data_driver
97    0000              section data_font
98    0000              section data_clib
99    0000                include "../../clib_data.inc"
1     0000              
2     0000              ;; clib data segments ;;;;;;;;;
3     0000              
4     0000              section data_alloc_balloc
5     0000              section data_alloc_malloc
6     0000              section data_fcntl
7     0000              section data_fcntl_stdio_heap_head
8     0000              section data_fcntl_stdio_heap_body
9     0000              section data_fcntl_stdio_heap_tail
10    0000              section data_fcntl_fdtable_body
11    0000              section data_sound_bit
12    0000              section data_stdio
13    0000              section data_stdlib
14    0000              section data_threads
15    0000              
16    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
17    0000              
100   0000                ;;section data_fcntl_stdio_heap_head
101   0000                ;;section data_fcntl_stdio_heap_body
102   0000                ;;section data_fcntl_stdio_heap_tail
103   0000                ;;section data_fcntl_fdtable_body
104   0000              section data_lib
105   0000              section data_compiler
106   0000              section data_user
107   0000              
108   0000              SECTION DATA_END
109   0000              
110   0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
111   0000              
112   0000              SECTION BSS
113   0000              
114   0000              IF __crt_org_bss
115   0000              
116   0000                 org __crt_org_bss
117   0000              
118   0000              ELSE
119   0000              
120   0000                 IF __crt_model
121   0000              
122   0000                    org -1
123   0000              
124   0000                 ENDIF
125   0000              
126   0000              ENDIF
127   0000              
128   0000  00          defb 0
129   0001              
130   0001              section BSS_UNINITIALIZED
131   0000              
132   0000              section bss_driver
133   0000              section bss_font
134   0000              section bss_clib
135   0000                include "../../clib_bss.inc"
1     0000              
2     0000              ;; clib bss segments ;;;;;;;;;;
3     0000              
4     0000              section bss_arch
5     0000              section bss_alloc_balloc
6     0000              section bss_alloc_malloc
7     0000              section bss_compress_aplib
8     0000              section bss_error
9     0000              section bss_fcntl
10    0000              section bss_input
11    0000              section bss_sound_bit
12    0000              section bss_stdio
13    0000              section bss_stdlib
14    0000              section bss_string
15    0000              
16    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
17    0000              
136   0000              section bss_lib
137   0000              section bss_compiler
138   0000              section bss_user
139   0000              
140   0000              SECTION BSS_END
141   0000              
142   0000              ;; end memory model ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
143   0000              
144   0000              
145   0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
146   0000              
147   0000              ENDIF
148   0000              
149   0000              ;; end memory model ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
150   0000              
22    0000              
23    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
24    0000              ;; GLOBAL SYMBOLS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
25    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
26    0000              
27    0000              include "../clib_constants.inc"
1     0000              
2     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
3     0000              ;; library constants ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
5     0000              
6     0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
7     0000                 ;; error
8     0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
9     0000              
10    0000                 ; keep consistent with "errno.h"
11    0000              
12    0000                 PUBLIC __EOK, __EACCES, __EBADF
13    0000                 PUBLIC __EBDFD, __EDOM, __EFBIG
14    0000                 PUBLIC __EINVAL, __EMFILE, __ENFILE
15    0000                 PUBLIC __ENOLCK, __ENOMEM, __ENOTSUP
16    0000                 PUBLIC __EOVERFLOW, __ERANGE, __ESTAT
17    0000                 PUBLIC __EWOULDBLOCK, __EAGAIN
18    0000              
19    0000                 defgroup
20    0000                 {
21    0000                    __EOK = 0,
22    0000                    __EACCES,
23    0000                    __EBADF,
24    0000                    __EBDFD,
25    0000                    __EDOM,
26    0000                    __EFBIG,
27    0000                    __EINVAL,
28    0000                    __EMFILE,
29    0000                    __ENFILE,
30    0000                    __ENOLCK,
31    0000                    __ENOMEM,
32    0000                    __ENOTSUP,
33    0000                    __EOVERFLOW,
34    0000                    __ERANGE,
35    0000                    __ESTAT,
36    0000                    __EWOULDBLOCK,
37    0000                    __EAGAIN = __EWOULDBLOCK,
38    0000              
39    0000                    ; define next error number for targets
40    0000              
41    0000                    __ERROR_NEXT__ = 50
42    0000                 }
43    0000              
44    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
45    0000                 ;; stdio
46    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
47    0000              
48    0000                 ; must not be changed consistent with "stdio.h"
49    0000              
50    0000                 PUBLIC STDIO_SEEK_SET, STDIO_SEEK_CUR, STDIO_SEEK_END
51    0000              
52    0000                 defc STDIO_SEEK_SET = 0
53    0000                 defc STDIO_SEEK_CUR = 1
54    0000                 defc STDIO_SEEK_END = 2
55    0000              
56    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
57    0000                 ;; threads
58    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
59    0000              
60    0000                 PUBLIC mtx_plain, mtx_recursive, mtx_timed
61    0000              
62    0000                 defc mtx_plain     = $01
63    0000                 defc mtx_recursive = $02
64    0000                 defc mtx_timed     = $04
65    0000              
66    0000                 PUBLIC thrd_success, thrd_error, thrd_nomem
67    0000                 PUBLIC thrd_busy, thrd_timedout
68    0000              
69    0000                 defc thrd_success  = $0000
70    0000                 defc thrd_error    = $0001
71    0000                 defc thrd_nomem    = $0002
72    0000                 defc thrd_busy     = $0004
73    0000                 defc thrd_timedout = $0008
74    0000              
75    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
76    0000                 ;; messages
77    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
78    0000              
79    0000                 ; relative sequence of these messages is significant
80    0000                 ; but can insert other messages as needed
81    0000              
82    0000                 PUBLIC STDIO_MSG_PUTC, STDIO_MSG_WRIT, STDIO_MSG_GETC
83    0000                 PUBLIC STDIO_MSG_EATC, STDIO_MSG_READ, STDIO_MSG_SEEK
84    0000                 PUBLIC STDIO_MSG_ICTL, STDIO_MSG_FLSH, STDIO_MSG_CLOS
85    0000              
86    0000                 PUBLIC ITERM_MSG_GETC, ITERM_MSG_PUTC, ITERM_MSG_PRINT_CURSOR
87    0000                 PUBLIC ITERM_MSG_ERASE_CURSOR, ITERM_MSG_BS, ITERM_MSG_BS_PWD
88    0000                 PUBLIC ITERM_MSG_READLINE_BEGIN, ITERM_MSG_READLINE_END, ITERM_MSG_BELL
89    0000                 PUBLIC ITERM_MSG_ERASE_CURSOR_PWD, ITERM_MSG_INTERRUPT
90    0000              
91    0000                 PUBLIC OTERM_MSG_PUTC, OTERM_MSG_TTY, OTERM_MSG_PRINTC
92    0000                 PUBLIC OTERM_MSG_SCROLL, OTERM_MSG_CLS, OTERM_MSG_PAUSE
93    0000                 PUBLIC OTERM_MSG_BELL, OTERM_MSG_PSCROLL
94    0000              
95    0000                 defgroup
96    0000                 {
97    0000                    ; stdio messages
98    0000              
99    0000                    STDIO_MSG_PUTC = 1,
100   0000                    STDIO_MSG_WRIT,
101   0000                    STDIO_MSG_GETC,
102   0000                    STDIO_MSG_EATC,
103   0000                    STDIO_MSG_READ,
104   0000                    STDIO_MSG_SEEK,
105   0000                    STDIO_MSG_ICTL,
106   0000                    STDIO_MSG_FLSH,
107   0000                    STDIO_MSG_CLOS,
108   0000              
109   0000                    ; input terminal messages
110   0000              
111   0000                    ITERM_MSG_GETC = 15,
112   0000                    ITERM_MSG_INTERRUPT,
113   0000                    ITERM_MSG_PUTC,
114   0000                    ITERM_MSG_PRINT_CURSOR,
115   0000                    ITERM_MSG_ERASE_CURSOR,
116   0000                    ITERM_MSG_ERASE_CURSOR_PWD,
117   0000                    ITERM_MSG_BS,
118   0000                    ITERM_MSG_BS_PWD,
119   0000                    ITERM_MSG_READLINE_BEGIN,
120   0000                    ITERM_MSG_READLINE_END,
121   0000                    ITERM_MSG_BELL,
122   0000              
123   0000                    __MESSAGE_ITERM_NEXT__,
124   0000              
125   0000                    ; output terminal messages
126   0000              
127   0000                    OTERM_MSG_PUTC = 30,
128   0000                    OTERM_MSG_TTY,
129   0000                    OTERM_MSG_PRINTC,
130   0000                    OTERM_MSG_SCROLL,
131   0000                    OTERM_MSG_CLS,
132   0000                    OTERM_MSG_PAUSE,
133   0000                    OTERM_MSG_BELL,
134   0000                    OTERM_MSG_PSCROLL,
135   0000              
136   0000                    __MESSAGE_OTERM_NEXT__,
137   0000              
138   0000                    ; define next message id for targets
139   0000              
140   0000                    __MESSAGE_NEXT__ = 45
141   0000              
142   0000                 }
143   0000              
144   0000                 ; serial character i/o messages
145   0000              
146   0000                 PUBLIC ICHAR_MSG_GETC
147   0000                 PUBLIC OCHAR_MSG_PUTC_BIN, OCHAR_MSG_PUTC
148   0000              
149   0000                 defc ICHAR_MSG_GETC     = ITERM_MSG_GETC
150   0000                 defc OCHAR_MSG_PUTC_BIN = OTERM_MSG_PUTC
151   0000                 defc OCHAR_MSG_PUTC     = OTERM_MSG_PRINTC
152   0000              
153   0000              
154   0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
155   0000                 ;; ioctls
156   0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
157   0000              
158   0000                 ; bit patterns are significant, consistent with "ioctl.h"
159   0000              
160   0000                 ; all devices, FILE type = $00
161   0000              
162   0000                 PUBLIC IOCTL_RESET
163   0000              
164   0000                 defc IOCTL_RESET = $0000
165   0000              
166   0000                 ; console_01_input_terminal, FILE type = $01
167   0000              
168   0000                 PUBLIC IOCTL_ITERM_ECHO, IOCTL_ITERM_PASS, IOCTL_ITERM_LINE
169   0000                 PUBLIC IOCTL_ITERM_COOK, IOCTL_ITERM_CAPS, IOCTL_ITERM_CRLF
170   0000                 PUBLIC IOCTL_ITERM_CURS
171   0000              
172   0000                 defc IOCTL_ITERM_ECHO = $c081
173   0000                 defc IOCTL_ITERM_PASS = $c041
174   0000                 defc IOCTL_ITERM_LINE = $c021
175   0000                 defc IOCTL_ITERM_COOK = $c011
176   0000                 defc IOCTL_ITERM_CAPS = $c009
177   0000                 defc IOCTL_ITERM_CRLF = $c101
178   0000                 defc IOCTL_ITERM_CURS = $c201
179   0000              
180   0000                 PUBLIC IOCTL_ITERM_TIE, IOCTL_ITERM_GET_EDITBUF, IOCTL_ITERM_SET_EDITBUF
181   0000              
182   0000                 defc IOCTL_ITERM_TIE         = $0201
183   0000                 defc IOCTL_ITERM_GET_EDITBUF = $0381
184   0000                 defc IOCTL_ITERM_SET_EDITBUF = $0301
185   0000              
186   0000                 ; console_01_output_terminal, FILE type = $02
187   0000              
188   0000                 PUBLIC IOCTL_OTERM_PAGE, IOCTL_OTERM_PAUSE, IOCTL_OTERM_COOK
189   0000                 PUBLIC IOCTL_OTERM_CRLF, IOCTL_OTERM_CLEAR, IOCTL_OTERM_SIGNAL
190   0000                 PUBLIC IOCTL_OTERM_BELL
191   0000              
192   0000                 defc IOCTL_OTERM_PAGE   = $c082
193   0000                 defc IOCTL_OTERM_PAUSE  = $c042
194   0000                 defc IOCTL_OTERM_COOK   = $c022
195   0000                 defc IOCTL_OTERM_CRLF   = $c012
196   0000                 defc IOCTL_OTERM_CLEAR  = $e002
197   0000                 defc IOCTL_OTERM_SIGNAL = $c202
198   0000                 defc IOCTL_OTERM_BELL   = $c102
199   0000              
200   0000                 PUBLIC IOCTL_OTERM_CLS, IOCTL_OTERM_RESET_SCROLL
201   0000                 PUBLIC IOCTL_OTERM_GET_WINDOW_COORD, IOCTL_OTERM_SET_WINDOW_COORD
202   0000                 PUBLIC IOCTL_OTERM_GET_WINDOW_RECT, IOCTL_OTERM_SET_WINDOW_RECT
203   0000                 PUBLIC IOCTL_OTERM_GET_CURSOR_COORD, IOCTL_OTERM_SET_CURSOR_COORD
204   0000                 PUBLIC IOCTL_OTERM_GET_OTERM, IOCTL_OTERM_SCROLL, IOCTL_OTERM_FONT
205   0000              
206   0000                 defc IOCTL_OTERM_CLS              = $0102
207   0000                 defc IOCTL_OTERM_RESET_SCROLL     = $0202
208   0000                 defc IOCTL_OTERM_GET_WINDOW_COORD = $0382
209   0000                 defc IOCTL_OTERM_SET_WINDOW_COORD = $0302
210   0000                 defc IOCTL_OTERM_GET_WINDOW_RECT  = $0482
211   0000                 defc IOCTL_OTERM_SET_WINDOW_RECT  = $0402
212   0000                 defc IOCTL_OTERM_GET_CURSOR_COORD = $0582
213   0000                 defc IOCTL_OTERM_SET_CURSOR_COORD = $0502
214   0000                 defc IOCTL_OTERM_GET_OTERM        = $0602
215   0000                 defc IOCTL_OTERM_SCROLL           = $0702
216   0000                 defc IOCTL_OTERM_FONT             = $0802
217   0000              
218   0000                 PUBLIC IOCTL_OTERM_FZX_GET_PAPER_COORD, IOCTL_OTERM_FZX_SET_PAPER_COORD
219   0000                 PUBLIC IOCTL_OTERM_FZX_GET_PAPER_RECT, IOCTL_OTERM_FZX_SET_PAPER_RECT
220   0000                 PUBLIC IOCTL_OTERM_FZX_LEFT_MARGIN, IOCTL_OTERM_FZX_LINE_SPACING
221   0000                 PUBLIC IOCTL_OTERM_FZX_SPACE_EXPAND
222   0000                 PUBLIC IOCTL_OTERM_FZX_GET_FZX_STATE, IOCTL_OTERM_FZX_SET_FZX_STATE
223   0000              
224   0000                 defc IOCTL_OTERM_FZX_GET_PAPER_COORD = $0a82
225   0000                 defc IOCTL_OTERM_FZX_SET_PAPER_COORD = $0a02
226   0000                 defc IOCTL_OTERM_FZX_GET_PAPER_RECT  = $0b82
227   0000                 defc IOCTL_OTERM_FZX_SET_PAPER_RECT  = $0b02
228   0000                 defc IOCTL_OTERM_FZX_LEFT_MARGIN     = $0c02
229   0000                 defc IOCTL_OTERM_FZX_LINE_SPACING    = $0d02
230   0000                 defc IOCTL_OTERM_FZX_SPACE_EXPAND    = $0e02
231   0000                 defc IOCTL_OTERM_FZX_GET_FZX_STATE   = $0f82
232   0000                 defc IOCTL_OTERM_FZX_SET_FZX_STATE   = $0f02
233   0000              
234   0000                 ; character_00_input, FILE type = $03
235   0000              
236   0000                 PUBLIC IOCTL_ICHAR_CRLF
237   0000              
238   0000                 defc IOCTL_ICHAR_CRLF = $c103
239   0000              
240   0000                 ; character_00_output, FILE type = $04
241   0000              
242   0000                 PUBLIC IOCTL_OCHAR_CRLF
243   0000              
244   0000                 defc IOCTL_OCHAR_CRLF = $c014
245   0000              
246   0000              ;; end library constants ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
247   0000              
28    0000              include "clib_target_constants.inc"
1     0000              
2     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
3     0000              ;; target library constants ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
5     0000              
6     0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
7     0000                 ;; target error
8     0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
9     0000              
10    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
11    0000                 ;; target messages
12    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
13    0000              
14    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
15    0000                 ;; target ioctls
16    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
17    0000              
18    0000              ;; end target library constants ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
19    0000              
29    0000              
30    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
31    0000              ;; INSTANTIATE DRIVERS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
32    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
33    0000              
34    0000              
35    0000              ; When FILEs and FDSTRUCTs are instantiated labels are assigned
36    0000              ; to point at created structures.
37    0000              ;
38    0000              ; The label formats are:
39    0000              ;
40    0000              ; __i_stdio_file_n     = address of static FILE structure #n (0..__I_STDIO_NUM_FILE-1)
41    0000              ; __i_fcntl_fdstruct_n = address of static FDSTRUCT #n (0..__I_FCNTL_NUM_FD-1)
42    0000              ; __i_fcntl_heap_n     = address of allocation #n on heap (0..__I_FCNTL_NUM_HEAP-1)
43    0000              
44    0000              
45    0000              
46    0000              ;; fd=0, stdin
47    0000              
48    0000              
49    0000              
50    0000              
51    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
52    0000                 ; FILE  : _stdin
53    0000                 ;
54    0000                 ; driver: zalt_00_input_sysctrl
55    0000                 ; fd    : 0
56    0000                 ; mode  : read only
57    0000                 ; type  : 003 = character input
58    0000                 ;
59    0000                 ; ioctl_flags   : 0x0100
60    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
61    0000              
62    0000              
63    0000                 SECTION data_clib
64    0000                 SECTION data_stdio
65    0000              
66    0000                 ; FILE *
67    0000              
68    0000                 PUBLIC _stdin
69    0000              
70    0000  04 00          _stdin:  defw __i_stdio_file_0 + 2
71    0002              
72    0002                 ; FILE structure
73    0002              
74    0002                 __i_stdio_file_0:
75    0002              
76    0002                    ; open files link
77    0002              
78    0002  00 00             defw 0
79    0004              
80    0004                    ; jump to underlying fd
81    0004              
82    0004  C3                defb 195			; jp (C3)
83    0005  06 00             defw __i_fcntl_fdstruct_0
84    0007              
85    0007                    ; state_flags_0
86    0007                    ; state_flags_1
87    0007                    ; conversion flags
88    0007                    ; ungetc
89    0007              
90    0007  40                defb 0x40      ; read + stdio manages ungetc + normal file type
91    0008  02                defb 0x02      ; last operation was read
92    0009  00                defb 0
93    000A  00                defb 0
94    000B              
95    000B                    ; mtx_recursive
96    000B              
97    000B  00                defb 0         ; thread owner = none
98    000C  02                defb 0x02      ; mtx_recursive
99    000D  00                defb 0         ; lock count = 0
100   000E  FE                defb 0xfe      ; atomic spinlock
101   000F  00 00             defw 0         ; list of blocked threads
102   0011              
103   0011              
104   0011                 ; fd table entry
105   0011              
106   0011                 SECTION data_fcntl_fdtable_body
107   0000  06 00          defw __i_fcntl_fdstruct_0
108   0002              
109   0002                 ; FDSTRUCT structure
110   0002              
111   0002                 SECTION data_fcntl_stdio_heap_body
112   0000              
113   0000                 EXTERN console_01_input_terminal_fdriver
114   0000                 EXTERN zalt_00_input_sysctrl
115   0000              
116   0000                 __i_fcntl_heap_0:
117   0000              
118   0000                    ; heap header
119   0000              
120   0000  17 00             defw __i_fcntl_heap_1
121   0002  17 00             defw 23
122   0004  00 00             defw 0
123   0006              
124   0006                 __i_fcntl_fdstruct_0:
125   0006              
126   0006                    ; FDSTRUCT structure
127   0006              
128   0006                    ; call to first entry to driver
129   0006              
130   0006  CD                defb 205
131   0007  00 00             defw console_01_input_terminal_fdriver
132   0009              
133   0009                    ; jump to driver
134   0009              
135   0009  C3                defb 195
136   000A  00 00             defw zalt_00_input_sysctrl
137   000C              
138   000C                    ; flags
139   000C                    ; reference_count
140   000C                    ; mode_byte
141   000C              
142   000C  03                defb 0x03      ; stdio handles ungetc + type = character input
143   000D  02                defb 2
144   000E  01                defb 0x01      ; read only
145   000F              
146   000F                    ; ioctl_flags
147   000F              
148   000F  00 01             defw 0x0100
149   0011              
150   0011                    ; mtx_plain
151   0011              
152   0011  00                defb 0         ; thread owner = none
153   0012  01                defb 0x01      ; mtx_plain
154   0013  00                defb 0         ; lock count = 0
155   0014  FE                defb 0xfe      ; atomic spinlock
156   0015  00 00             defw 0         ; list of blocked threads
157   0017              
158   0017              
159   0017                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
160   0017              
161   0017              
162   0017              ;; fd=1, stdout
163   0017              
164   0017              
165   0017              
166   0017              
167   0017                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
168   0017                 ; FILE  : _stdout
169   0017                 ;
170   0017                 ; driver: zalt_00_output_sysctrl
171   0017                 ; fd    : 1
172   0017                 ; mode  : write only
173   0017                 ; type  : 004 = character output
174   0017                 ;
175   0017                 ; ioctl_flags   : 0x0010
176   0017                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
177   0017              
178   0017              
179   0017                 SECTION data_clib
180   0000                 SECTION data_stdio
181   0011              
182   0011                 ; FILE *
183   0011              
184   0011                 PUBLIC _stdout
185   0011              
186   0011  15 00          _stdout:  defw __i_stdio_file_1 + 2
187   0013              
188   0013                 ; FILE structure
189   0013              
190   0013                 __i_stdio_file_1:
191   0013              
192   0013                    ; open files link
193   0013              
194   0013  02 00             defw __i_stdio_file_0
195   0015              
196   0015                    ; jump to underlying fd
197   0015              
198   0015  C3                defb 195			; jp (C3)
199   0016  1D 00             defw __i_fcntl_fdstruct_1
200   0018              
201   0018                    ; state_flags_0
202   0018                    ; state_flags_1
203   0018                    ; conversion flags
204   0018                    ; ungetc
205   0018              
206   0018  80                defb 0x80         ; write + normal file type
207   0019  00                defb 0            ; last operation was write
208   001A  00                defb 0
209   001B  00                defb 0
210   001C              
211   001C                    ; mtx_recursive
212   001C              
213   001C  00                defb 0         ; thread owner = none
214   001D  02                defb 0x02      ; mtx_recursive
215   001E  00                defb 0         ; lock count = 0
216   001F  FE                defb 0xfe      ; atomic spinlock
217   0020  00 00             defw 0         ; list of blocked threads
218   0022              
219   0022              
220   0022                 ; fd table entry
221   0022              
222   0022                 SECTION data_fcntl_fdtable_body
223   0002  1D 00          defw __i_fcntl_fdstruct_1
224   0004              
225   0004                 ; FDSTRUCT structure
226   0004              
227   0004                 SECTION data_fcntl_stdio_heap_body
228   0017              
229   0017                 EXTERN console_01_output_terminal_fdriver
230   0017                 EXTERN zalt_00_output_sysctrl
231   0017              
232   0017                 __i_fcntl_heap_1:
233   0017              
234   0017                    ; heap header
235   0017              
236   0017  2E 00             defw __i_fcntl_heap_2
237   0019  17 00             defw 23
238   001B  00 00             defw __i_fcntl_heap_0
239   001D              
240   001D                 __i_fcntl_fdstruct_1:
241   001D              
242   001D                    ; FDSTRUCT structure
243   001D              
244   001D                    ; call to first entry to driver
245   001D              
246   001D  CD                defb 205
247   001E  00 00             defw console_01_output_terminal_fdriver
248   0020              
249   0020                    ; jump to driver
250   0020              
251   0020  C3                defb 195
252   0021  00 00             defw zalt_00_output_sysctrl
253   0023              
254   0023                    ; flags
255   0023                    ; reference_count
256   0023                    ; mode_byte
257   0023              
258   0023  04                defb 0x04      ; type = character output
259   0024  02                defb 2
260   0025  02                defb 0x02      ; write only
261   0026              
262   0026                    ; ioctl_flags
263   0026              
264   0026  10 00             defw 0x0010
265   0028              
266   0028                    ; mtx_plain
267   0028              
268   0028  00                defb 0         ; thread owner = none
269   0029  01                defb 0x01      ; mtx_plain
270   002A  00                defb 0         ; lock count = 0
271   002B  FE                defb 0xfe      ; atomic spinlock
272   002C  00 00             defw 0         ; list of blocked threads
273   002E              
274   002E              
275   002E                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
276   002E              
277   002E              
278   002E              ;; fd=2, stderr
279   002E              
280   002E              
281   002E              
282   002E                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
283   002E                 ; DUPED FILE DESCRIPTOR
284   002E                 ;
285   002E                 ; FILE  : _stderr
286   002E                 ; flags : 0x80
287   002E                 ;
288   002E                 ; fd    : 2
289   002E                 ; dup fd: __i_fcntl_fdstruct_1
290   002E                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
291   002E              
292   002E              
293   002E                 SECTION data_clib
294   0000                 SECTION data_stdio
295   0022              
296   0022                 ; FILE *
297   0022              
298   0022                 PUBLIC _stderr
299   0022              
300   0022  26 00          _stderr:  defw __i_stdio_file_2 + 2
301   0024              
302   0024                 ; FILE structure
303   0024              
304   0024                 __i_stdio_file_2:
305   0024              
306   0024                    ; open files link
307   0024              
308   0024  13 00             defw __i_stdio_file_1
309   0026              
310   0026                    ; jump to duped fd
311   0026              
312   0026  C3                defb 195
313   0027  1D 00             defw __i_fcntl_fdstruct_1
314   0029              
315   0029                    ; state_flags_0
316   0029                    ; state_flags_1
317   0029                    ; conversion flags
318   0029                    ; ungetc
319   0029              
320   0029  80                defb 0x80
321   002A  00                defb 0
322   002B  00                defb 0
323   002C  00                defb 0
324   002D              
325   002D                    ; mtx_recursive
326   002D              
327   002D  00                defb 0         ; thread owner = none
328   002E  02                defb 0x02      ; mtx_recursive
329   002F  00                defb 0         ; lock count = 0
330   0030  FE                defb 0xfe      ; atomic spinlock
331   0031  00 00             defw 0         ; list of blocked threads
332   0033              
333   0033              
334   0033                 ; fd table entry
335   0033              
336   0033                 SECTION data_fcntl_fdtable_body
337   0004  1D 00          defw __i_fcntl_fdstruct_1
338   0006              
339   0006                 ; FDSTRUCT structure
340   0006              
341   0006                 defc __i_fcntl_fdstruct_2 = __i_fcntl_fdstruct_1
342   0006              
343   0006                 ; adjust reference count on duped FDSTRUCT
344   0006              
345   0006                 SECTION code_crt_init
346   0000              
347   0000  21 24 00       ld hl,__i_fcntl_fdstruct_1 + 7     ; & FDSTRUCT.ref_count
348   0003  34             inc (hl)
349   0004  34             inc (hl)
350   0005              
351   0005              
352   0005                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
353   0005              
354   0005              
355   0005              
356   0005                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
357   0005                 ;; create open and closed FILE lists
358   0005                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
359   0005              
360   0005                 ; __clib_fopen_max   = max number of open FILEs specified by user
361   0005                 ; 3 = number of static FILEs instantiated in crt
362   0005                 ; __i_stdio_file_n   = address of static FILE structure #n (0..I_STDIO_FILE_NUM-1)
363   0005              
364   0005                 SECTION data_clib
365   0000                 SECTION data_stdio
366   0033              
367   0033                 IF (__clib_fopen_max > 0) || (3 > 0)
368   0033              
369   0033                    ; number of FILEs > 0
370   0033              
371   0033                    ; construct list of open files
372   0033              
373   0033                    IF 3 > 0
374   0033              
375   0033                       ; number of FILEs statically generated > 0
376   0033              
377   0033                       SECTION data_clib
378   0000                       SECTION data_stdio
379   0033              
380   0033                       PUBLIC __stdio_open_file_list
381   0033              
382   0033  24 00                __stdio_open_file_list:  defw __i_stdio_file_2
383   0035              
384   0035                    ELSE
385   0035              
386   0035                       ; number of FILEs statically generated = 0
387   0035              
388   0035                       SECTION bss_clib
389   0035                       SECTION bss_stdio
390   0035              
391   0035                       PUBLIC __stdio_open_file_list
392   0035              
393   0035                       __stdio_open_file_list:  defw 0
394   0035              
395   0035                    ENDIF
396   0035              
397   0035                    ; construct list of closed / available FILEs
398   0035              
399   0035                    SECTION data_clib
400   0000                    SECTION data_stdio
401   0035              
402   0035                    PUBLIC __stdio_closed_file_list
403   0035              
404   0035  00 00 35 00       __stdio_closed_file_list:   defw 0, __stdio_closed_file_list
405   0039              
406   0039                    IF __clib_fopen_max > 3
407   0039              
408   0039                       ; create extra FILE structures
409   0039              
410   0039                       SECTION bss_clib
411   0039                       SECTION bss_stdio
412   0039              
413   0039                       __stdio_file_extra:      defs (__clib_fopen_max - 3) * 15
414   0039              
415   0039                       SECTION code_crt_init
416   0039              
417   0039                          ld bc,__stdio_closed_file_list
418   0039                          ld de,__stdio_file_extra
419   0039                          ld l,__clib_fopen_max - 3
420   0039              
421   0039                       loop:
422   0039              
423   0039                          push hl
424   0039              
425   0039                          EXTERN asm_p_forward_list_alt_push_front
426   0039                          call asm_p_forward_list_alt_push_front
427   0039              
428   0039                          ld de,15
429   0039                          add hl,de
430   0039                          ex de,hl
431   0039              
432   0039                          pop hl
433   0039              
434   0039                          dec l
435   0039                          jr nz, loop
436   0039              
437   0039                    ENDIF
438   0039              
439   0039                 ENDIF
440   0039              
441   0039                 IF (__clib_fopen_max = 0) && (3 = 0)
442   0039              
443   0039                    ; create empty file lists
444   0039              
445   0039                    SECTION bss_clib
446   0039                    SECTION bss_stdio
447   0039              
448   0039                    PUBLIC __stdio_open_file_list
449   0039                    __stdio_open_file_list:  defw 0
450   0039              
451   0039                    SECTION data_clib
452   0039                    SECTION data_stdio
453   0039              
454   0039                    PUBLIC __stdio_closed_file_list
455   0039                    __stdio_closed_file_list:   defw 0, __stdio_closed_file_list
456   0039              
457   0039                 ENDIF
458   0039              
459   0039                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
460   0039                 ;; create fd table
461   0039                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
462   0039              
463   0039                 ; __clib_open_max  = max number of open fds specified by user
464   0039                 ; 3 = number of static file descriptors created
465   0039              
466   0039                 PUBLIC __fcntl_fdtbl
467   0039                 PUBLIC __fcntl_fdtbl_size
468   0039              
469   0039                 IF 3 > 0
470   0039              
471   0039                    ; create rest of fd table in data segment
472   0039              
473   0039                    SECTION data_fcntl_fdtable_body
474   0006              
475   0006                    EXTERN __data_fcntl_fdtable_body_head
476   0006              
477   0006                    defc __fcntl_fdtbl = __data_fcntl_fdtable_body_head
478   0006              
479   0006                    IF __clib_open_max > 3
480   0006              
481   0006                       SECTION data_fcntl_fdtable_body
482   0006              
483   0006                       defs (__clib_open_max - 3) * 2
484   0006                       defc __fcntl_fdtbl_size = __clib_open_max
485   0006              
486   0006                    ELSE
487   0006              
488   0006                       defc __fcntl_fdtbl_size = 3
489   0006              
490   0006                    ENDIF
491   0006              
492   0006                 ELSE
493   0006              
494   0006                    IF __clib_open_max > 0
495   0006              
496   0006                       ; create fd table in bss segment
497   0006              
498   0006                       SECTION bss_clib
499   0006                       SECTION bss_fcntl
500   0006              
501   0006                       __fcntl_fdtbl:        defs __clib_open_max * 2
502   0006              
503   0006                    ELSE
504   0006              
505   0006                       ; no fd table at all
506   0006              
507   0006                       defc __fcntl_fdtbl = 0
508   0006              
509   0006                    ENDIF
510   0006              
511   0006                    defc __fcntl_fdtbl_size = __clib_open_max
512   0006              
513   0006                 ENDIF
514   0006              
515   0006                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
516   0006                 ;; finalize stdio heap
517   0006                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
518   0006              
519   0006                 ; __clib_stdio_heap_size  = desired stdio heap size in bytes
520   0006                 ; 46  = byte size of static FDSTRUCTs
521   0006                 ; 2   = number of heap allocations
522   0006                 ; __i_fcntl_heap_n     = address of allocation #n on heap (0..__I_FCNTL_NUM_HEAP-1)
523   0006              
524   0006                 IF 46 > 0
525   0006              
526   0006                    ; static FDSTRUCTs have been allocated in the heap
527   0006              
528   0006                    SECTION data_clib
529   0000                    SECTION data_fcntl
530   0000              
531   0000                    PUBLIC __stdio_heap
532   0000              
533   0000  00 00             __stdio_heap:            defw __stdio_block
534   0002              
535   0002                    SECTION data_fcntl_stdio_heap_head
536   0000              
537   0000                    __stdio_block:
538   0000              
539   0000  00                   defb 0                ; no owner
540   0001  01                   defb 0x01             ; mtx_plain
541   0002  00                   defb 0                ; number of lock acquisitions
542   0003  FE                   defb 0xfe             ; spinlock (unlocked)
543   0004  00 00                defw 0                ; list of threads blocked on mutex
544   0006              
545   0006                    IF __clib_stdio_heap_size > (46 + 14)
546   0006              
547   0006                       ; expand stdio heap to desired size
548   0006              
549   0006                       SECTION data_fcntl_stdio_heap_body
550   002E              
551   002E                       __i_fcntl_heap_2:
552   002E              
553   002E  00 00                   defw __i_fcntl_heap_3
554   0030  00 00                   defw 0
555   0032  17 00                   defw __i_fcntl_heap_1
556   0034  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      0054  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      0074  00 00 00 00 
                                    defs __clib_stdio_heap_size - 46 - 14
557   0078              
558   0078                       ; terminate stdio heap
559   0078              
560   0078                       SECTION data_fcntl_stdio_heap_tail
561   0000              
562   0000  00 00                __i_fcntl_heap_3:   defw 0
563   0002              
564   0002                    ELSE
565   0002              
566   0002                       ; terminate stdio heap
567   0002              
568   0002                       SECTION data_fcntl_stdio_heap_tail
569   0002              
570   0002                       __i_fcntl_heap_2:   defw 0
571   0002              
572   0002                    ENDIF
573   0002              
574   0002                 ELSE
575   0002              
576   0002                    ; no FDSTRUCTs statically created
577   0002              
578   0002                    IF __clib_stdio_heap_size > 14
579   0002              
580   0002                       SECTION data_clib
581   0002                       SECTION data_fcntl
582   0002              
583   0002                       PUBLIC __stdio_heap
584   0002              
585   0002                       __stdio_heap:         defw __stdio_block
586   0002              
587   0002                       SECTION bss_clib
588   0002                       SECTION bss_fcntl
589   0002              
590   0002                       PUBLIC __stdio_block
591   0002              
592   0002                       __stdio_block:         defs __clib_stdio_heap_size
593   0002              
594   0002                       SECTION code_crt_init
595   0002              
596   0002                       ld hl,__stdio_block
597   0002                       ld bc,__clib_stdio_heap_size
598   0002              
599   0002                       EXTERN asm_heap_init
600   0002                       call asm_heap_init
601   0002              
602   0002                    ENDIF
603   0002              
604   0002                 ENDIF
605   0002              
606   0002              
607   0002              
608   0002              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
609   0002              ;; STARTUP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
610   0002              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
611   0002              
612   0002              SECTION CODE
613   0000              
614   0000              ; exports
615   0000              public __Start, __Exit
616   0000              
617   0000              ; imports
618   0000              extern _main
619   0000              
620   0000              ;**************************************************************
621   0000              IF __crt_org_code = 0
622   0000              ;**************************************************************
623   0000              
624   0000                 ; address = 0x0000
625   0000                 ; page0 and isr_vectortable have a fixed org
626   0000                 include "startup/page0.asm"
1     0000              ;
2     0000              ; This file defines the memory layout for page zero.
3     0000              ;
4     0000              
5     0000              ; exports
6     0000              public bios_load_byte_instruction
7     0000              public bios_load_word_instruction
8     0000              ; export bios vars
9     0000              public bios_var_ram_top_page
10    0000              public bios_var_ram_page
11    0000              public bios_var_ram_active_page
12    0000              
13    0000              ; imports
14    0000              extern bios_reset_init
15    0000              extern bios_trap_illegal
16    0000              
17    0000              ifdef DEBUG
18    0000              extern debug_save_registers
19    0000              extern debug_infopoint
20    0000              endif
21    0000              
22    0000              module page0
23    0000              
24    0000              ; Declares fixed addresses and startup routines
25    0000              
26    0000              ;
27    0000              ; Page-0 memory layout
28    0000              ;
29    0000              
30    0000              	;defs 0x0000 - ASMPC
31    0000              ; address = 0x0000
32    0000              ; !RESET and RST00
33    0000  F3          	di						; from warm boot (rst00), interrupts may be enabled
34    0001  C3 04 02    	jp	bios_reset_init
35    0004              
36    0004  00 00 00 00 	defs 0x0008 - ASMPC
37    0008              	; address = 0x0008
38    0008              	; RTS08
39    0008              	;	di					; if you need interrupts disabled, do that here
40    0008  C3 7B 00    	jp	BiosFn1
41    000B              
42    000B              
43    000B  00 00 00 00 00 
                        	defs 0x0010 - ASMPC
44    0010              	; address = 0x0010
45    0010              	; RST10
46    0010              	;	di					; if you need interrupts disabled, do that here
47    0010  C3 7B 00    	jp	BiosFn2
48    0013              
49    0013  00 00 00 00 00 
                        	defs 0x0018 - ASMPC
50    0018              	; address = 0x0018
51    0018              	; RST18
52    0018              	;	di					; if you need interrupts disabled, do that here
53    0018  C3 7B 00    	jp	BiosFn3
54    001B              
55    001B              
56    001B  00 00 00 00 00 
                        	defs 0x0020 - ASMPC
57    0020              	; address = 0x0020
58    0020              	; RST20
59    0020              	;	di					; if you need interrupts disabled, do that here
60    0020  C3 7B 00    	jp	BiosFn4
61    0023              
62    0023              
63    0023  00 00 00 00 00 
                        	defs 0x0028 - ASMPC
64    0028              	; address = 0x0028
65    0028              	; RST28
66    0028              	;	di					; if you need interrupts disabled, do that here
67    0028  C3 7B 00    	jp	BiosFn5
68    002B              
69    002B              
70    002B  00 00 00 00 00 
                        	defs 0x0030 - ASMPC
71    0030              	; address = 0x0030
72    0030              	; RST30
73    0030              	;	di					; if you need interrupts disabled, do that here
74    0030  C3 7B 00    	jp	BiosFn6
75    0033              
76    0033              
77    0033  00 00 00 00 00 
                        	defs 0x0038 - ASMPC
78    0038              	; address = 0x0038
79    0038              	; RST38 and IM1
80    0038              	; used to trap illegal jumps and interrupt mode
81    0038  F3          	di							; disable interrupts
82    0039              ifdef DEBUG
83    0039              	call debug_save_registers	; save cpu state
84    0039              endif
85    0039  C3 03 02    	jp	bios_trap_illegal		; call the handler for illegal calls.
86    003C              
87    003C              
88    003C              ; bios vars
89    003C  00 00 00 00 	defs 0x0040 - ASMPC
90    0040              bios_var_ram_top_page:
91    0040  00          	defb $00		; last valid ram page
92    0041              bios_var_ram_top:
93    0041  00 00       	defw $0000		; last valid ram address on last page
94    0043              bios_var_ram_active_page:
95    0043  00          	defb $00		; current active ram page
96    0044              
97    0044              
98    0044  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      0064  00 00 
                        	defs 0x0066 - ASMPC
99    0066              	; address = 0x0066
100   0066              	; !NMI
101   0066              ;ifdef DEBUG
102   0066              ;	call debug_save_registers	; save cpu state
103   0066  CD 78 00    	call debug_infopoint		; communicate InfoPoint to SystemController
104   0069              ;endif
105   0069  ED 45       	retn
106   006B              
107   006B              
108   006B              
109   006B              ; When a program calls an RST function its PC is stored on the SP.
110   006B              ; The RST function can define an additional byte (or two) immediate after the RST instruction.
111   006B              ; This extra information would have meaning for the RST operation.
112   006B              
113   006B              ; This method reads the single byte that follows the RST instruction
114   006B              ; and adjusts the returns address to return control after that byte.
115   006B              ; rst{n} defb $xx
116   006B              ; pre-condition:
117   006B              ;	The SP contains a direct return address used to return from this method
118   006B              ;	and it contains the return address from where the RST method was called -
119   006B              ;	that will be adjusted.
120   006B              ; post-condition:
121   006B              ;	Register a will contain the extra RST byte and the RST return address is adjusted.
122   006B              bios_load_byte_instruction:
123   006B  D1          	pop de		; this is the immediate return address and must be preserved.
124   006C  E1          	pop	hl		; this is the RST return address and must be adjusted
125   006D  7E          	ld a, (hl)	; get the extra byte
126   006E  23          	inc hl		; set RST return address past the data byte
127   006F  E5          	push hl		; put RST return address back on stack
128   0070  D5          	push de		; as well as the immediate return address
129   0071  C9          	ret
130   0072              
131   0072              ; This method reads two bytes (a word) that follows the RST instruction
132   0072              ; and adjusts the returns address to return control after that word.
133   0072              ; rst{n} defw $xxxx
134   0072              ; pre-condition:
135   0072              ;	The SP contains a direct return address used to return from this method
136   0072              ;	and it contains the return address from where the RST method was called -
137   0072              ;	that will be adjusted.
138   0072              ;	The word bytes are little endian: so the first is LSB and the next is MSB.
139   0072              ; post-condition:
140   0072              ;	Register bc will contain the extra RST bytes and the RST return address is adjusted.
141   0072              ;	Register c contains the first (lsb) and b contains the second (msb) byte after the RST instruction.
142   0072              bios_load_word_instruction:
143   0072  D1          	pop de		; this is the immediate return address and must be preserved.
144   0073  E1          	pop	hl		; this is the RST return address and must be adjusted
145   0074  4E          	ld c, (hl)	; get the first extra byte
146   0075  23          	inc hl		; prepare to get the next data byte
147   0076  46          	ld b, (hl)	; get the next extra byte
148   0077  23          	inc hl		; set RST return address past the data word
149   0078  E5          	push hl		; put RST return address back on stack
150   0079  D5          	push de		; as well as the immediate return address
151   007A  C9          	ret
152   007B              
153   007B              BiosFn1:
154   007B              ; bios function #1
155   007B              
156   007B              BiosFn2:
157   007B              ; bios function #2
158   007B              
159   007B              BiosFn3:
160   007B              ; bios function #3
161   007B              
162   007B              BiosFn4:
163   007B              ; bios function #4
164   007B              
165   007B              BiosFn5:
166   007B              ; bios function #5
167   007B              
168   007B              BiosFn6:
169   007B              ; bios function #6
170   007B  76          	halt
171   007C              
172   007C              
173   007C              ;
174   007C              ; ISR Table (IM2) of 16-bit jump addresses (I=1) 256 bytes max
175   007C              ;
176   007C              
177   007C              ; ISR Table is located at page 1 ($0100, I=1).
178   007C              defc isr_table_address 	= $0100		; hi-byte is same as the isr_table_index
179   007C              defc isr_table_index 	= 1         ; used to initialie I register
180   007C              defc isr_table_address_end = isr_table_address + $0100	; 256 byte of isr table
181   007C              
182   007C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      009C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      00BC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      00DC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      00FC  00 00 00 00 
                        defs isr_table_address - ASMPC
183   0100              
184   0100              ; The lo address byte (A1-A7: A0=0) is put on the databus by the interrupting device.
185   0100              ; The hi address byte (A8-A15) is supplied by the I register that is initialized to (page) 1.
186   0100  00 02       defw	isr_null_vector		; Address of ISR #0
187   0102  00 02       defw	isr_null_vector		; Address of ISR #1
188   0104  00 02       defw	isr_null_vector		; Address of ISR #2
189   0106  00 02       defw	isr_null_vector		; Address of ISR #3
190   0108  00 02       defw	isr_null_vector		; Address of ISR #4
191   010A  00 02       defw	isr_null_vector		; Address of ISR #5
192   010C  00 02       defw	isr_null_vector		; Address of ISR #6
193   010E  00 02       defw	isr_null_vector		; Address of ISR #7
194   0110  00 02       defw	isr_null_vector		; Address of ISR #8
195   0112  00 02       defw	isr_null_vector		; Address of ISR #9
196   0114  00 02       defw	isr_null_vector		; Address of ISR #10
197   0116  00 02       defw	isr_null_vector		; Address of ISR #11
198   0118  00 02       defw	isr_null_vector		; Address of ISR #12
199   011A  00 02       defw	isr_null_vector		; Address of ISR #13
200   011C  00 02       defw	isr_null_vector		; Address of ISR #14
201   011E  00 02       defw	isr_null_vector		; Address of ISR #15
202   0120  00 02       defw	isr_null_vector		; Address of ISR #16
203   0122  00 02       defw	isr_null_vector		; Address of ISR #17
204   0124  00 02       defw	isr_null_vector		; Address of ISR #18
205   0126  00 02       defw	isr_null_vector		; Address of ISR #19
206   0128  00 02       defw	isr_null_vector		; Address of ISR #20
207   012A  00 02       defw	isr_null_vector		; Address of ISR #21
208   012C  00 02       defw	isr_null_vector		; Address of ISR #22
209   012E  00 02       defw	isr_null_vector		; Address of ISR #23
210   0130  00 02       defw	isr_null_vector		; Address of ISR #24
211   0132  00 02       defw	isr_null_vector		; Address of ISR #25
212   0134  00 02       defw	isr_null_vector		; Address of ISR #26
213   0136  00 02       defw	isr_null_vector		; Address of ISR #27
214   0138  00 02       defw	isr_null_vector		; Address of ISR #28
215   013A  00 02       defw	isr_null_vector		; Address of ISR #29
216   013C  00 02       defw	isr_null_vector		; Address of ISR #30
217   013E  00 02       defw	isr_null_vector		; Address of ISR #31
218   0140  00 02       defw	isr_null_vector		; Address of ISR #32
219   0142  00 02       defw	isr_null_vector		; Address of ISR #33
220   0144  00 02       defw	isr_null_vector		; Address of ISR #34
221   0146  00 02       defw	isr_null_vector		; Address of ISR #35
222   0148  00 02       defw	isr_null_vector		; Address of ISR #36
223   014A  00 02       defw	isr_null_vector		; Address of ISR #37
224   014C  00 02       defw	isr_null_vector		; Address of ISR #38
225   014E  00 02       defw	isr_null_vector		; Address of ISR #39
226   0150  00 02       defw	isr_null_vector		; Address of ISR #40
227   0152  00 02       defw	isr_null_vector		; Address of ISR #41
228   0154  00 02       defw	isr_null_vector		; Address of ISR #42
229   0156  00 02       defw	isr_null_vector		; Address of ISR #43
230   0158  00 02       defw	isr_null_vector		; Address of ISR #44
231   015A  00 02       defw	isr_null_vector		; Address of ISR #45
232   015C  00 02       defw	isr_null_vector		; Address of ISR #46
233   015E  00 02       defw	isr_null_vector		; Address of ISR #47
234   0160  00 02       defw	isr_null_vector		; Address of ISR #48
235   0162  00 02       defw	isr_null_vector		; Address of ISR #49
236   0164  00 02       defw	isr_null_vector		; Address of ISR #50
237   0166  00 02       defw	isr_null_vector		; Address of ISR #51
238   0168  00 02       defw	isr_null_vector		; Address of ISR #52
239   016A  00 02       defw	isr_null_vector		; Address of ISR #53
240   016C  00 02       defw	isr_null_vector		; Address of ISR #54
241   016E  00 02       defw	isr_null_vector		; Address of ISR #55
242   0170  00 02       defw	isr_null_vector		; Address of ISR #56
243   0172  00 02       defw	isr_null_vector		; Address of ISR #57
244   0174  00 02       defw	isr_null_vector		; Address of ISR #58
245   0176  00 02       defw	isr_null_vector		; Address of ISR #59
246   0178  00 02       defw	isr_null_vector		; Address of ISR #60
247   017A  00 02       defw	isr_null_vector		; Address of ISR #61
248   017C  00 02       defw	isr_null_vector		; Address of ISR #62
249   017E  00 02       defw	isr_null_vector		; Address of ISR #63
250   0180  00 02       defw	isr_null_vector		; Address of ISR #64
251   0182  00 02       defw	isr_null_vector		; Address of ISR #65
252   0184  00 02       defw	isr_null_vector		; Address of ISR #66
253   0186  00 02       defw	isr_null_vector		; Address of ISR #67
254   0188  00 02       defw	isr_null_vector		; Address of ISR #68
255   018A  00 02       defw	isr_null_vector		; Address of ISR #69
256   018C  00 02       defw	isr_null_vector		; Address of ISR #70
257   018E  00 02       defw	isr_null_vector		; Address of ISR #71
258   0190  00 02       defw	isr_null_vector		; Address of ISR #72
259   0192  00 02       defw	isr_null_vector		; Address of ISR #73
260   0194  00 02       defw	isr_null_vector		; Address of ISR #74
261   0196  00 02       defw	isr_null_vector		; Address of ISR #75
262   0198  00 02       defw	isr_null_vector		; Address of ISR #76
263   019A  00 02       defw	isr_null_vector		; Address of ISR #77
264   019C  00 02       defw	isr_null_vector		; Address of ISR #78
265   019E  00 02       defw	isr_null_vector		; Address of ISR #79
266   01A0  00 02       defw	isr_null_vector		; Address of ISR #80
267   01A2  00 02       defw	isr_null_vector		; Address of ISR #81
268   01A4  00 02       defw	isr_null_vector		; Address of ISR #82
269   01A6  00 02       defw	isr_null_vector		; Address of ISR #83
270   01A8  00 02       defw	isr_null_vector		; Address of ISR #84
271   01AA  00 02       defw	isr_null_vector		; Address of ISR #85
272   01AC  00 02       defw	isr_null_vector		; Address of ISR #86
273   01AE  00 02       defw	isr_null_vector		; Address of ISR #87
274   01B0  00 02       defw	isr_null_vector		; Address of ISR #88
275   01B2  00 02       defw	isr_null_vector		; Address of ISR #89
276   01B4  00 02       defw	isr_null_vector		; Address of ISR #90
277   01B6  00 02       defw	isr_null_vector		; Address of ISR #91
278   01B8  00 02       defw	isr_null_vector		; Address of ISR #92
279   01BA  00 02       defw	isr_null_vector		; Address of ISR #93
280   01BC  00 02       defw	isr_null_vector		; Address of ISR #94
281   01BE  00 02       defw	isr_null_vector		; Address of ISR #95
282   01C0  00 02       defw	isr_null_vector		; Address of ISR #96
283   01C2  00 02       defw	isr_null_vector		; Address of ISR #97
284   01C4  00 02       defw	isr_null_vector		; Address of ISR #98
285   01C6  00 02       defw	isr_null_vector		; Address of ISR #99
286   01C8  00 02       defw	isr_null_vector		; Address of ISR #100
287   01CA  00 02       defw	isr_null_vector		; Address of ISR #101
288   01CC  00 02       defw	isr_null_vector		; Address of ISR #102
289   01CE  00 02       defw	isr_null_vector		; Address of ISR #103
290   01D0  00 02       defw	isr_null_vector		; Address of ISR #104
291   01D2  00 02       defw	isr_null_vector		; Address of ISR #105
292   01D4  00 02       defw	isr_null_vector		; Address of ISR #106
293   01D6  00 02       defw	isr_null_vector		; Address of ISR #107
294   01D8  00 02       defw	isr_null_vector		; Address of ISR #108
295   01DA  00 02       defw	isr_null_vector		; Address of ISR #109
296   01DC  00 02       defw	isr_null_vector		; Address of ISR #110
297   01DE  00 02       defw	isr_null_vector		; Address of ISR #111
298   01E0  00 02       defw	isr_null_vector		; Address of ISR #112
299   01E2  00 02       defw	isr_null_vector		; Address of ISR #113
300   01E4  00 02       defw	isr_null_vector		; Address of ISR #114
301   01E6  00 02       defw	isr_null_vector		; Address of ISR #115
302   01E8  00 02       defw	isr_null_vector		; Address of ISR #116
303   01EA  00 02       defw	isr_null_vector		; Address of ISR #117
304   01EC  00 02       defw	isr_null_vector		; Address of ISR #118
305   01EE  00 02       defw	isr_null_vector		; Address of ISR #119
306   01F0  00 02       defw	isr_null_vector		; Address of ISR #120
307   01F2  00 02       defw	isr_null_vector		; Address of ISR #121
308   01F4  00 02       defw	isr_null_vector		; Address of ISR #122
309   01F6  00 02       defw	isr_null_vector		; Address of ISR #123
310   01F8  00 02       defw	isr_null_vector		; Address of ISR #124
311   01FA  00 02       defw	isr_null_vector		; Address of ISR #125
312   01FC  00 02       defw	isr_null_vector		; Address of ISR #126
313   01FE  00 02       defw	isr_null_vector		; Address of ISR #127
314   0200              
627   0200                 include "startup/bios.asm"
1     0200              ;
2     0200              ; bios.asm
3     0200              ;
4     0200              
5     0200              ; exports
6     0200              public bios_reset_init
7     0200              public isr_null_vector
8     0200              public bios_trap_illegal
9     0200              
10    0200              ; imports
11    0200              
12    0200              
13    0200              ;
14    0200              ; Start of bios
15    0200              ;
16    0200              
17    0200              ; a dummy isr for initializing the isr vector table
18    0200              isr_null_vector:
19    0200              ifdef DEBUG
20    0200              	halt			; break if debug build
21    0200              endif
22    0200  FB          	ei				; lets do that again
23    0201  ED 4D       	reti			; do nothing, return from interrupt
24    0203              
25    0203              ;	hl contains the source address of illegal call
26    0203              bios_trap_illegal:
27    0203              ifdef DEBUG
28    0203              	halt			; break if debug build
29    0203              endif
30    0203  C7          	rst $00			; reset
31    0204              
32    0204              ; Interrupts are disabled.
33    0204              bios_reset_init:
34    0204  AF          	xor a
35    0205  47          	ld b, a
36    0206  4F          	ld c, a
37    0207  57          	ld d, a
38    0208  5F          	ld e, a
39    0209  67          	ld h, a
40    020A  6F          	ld l, a
41    020B  DD 21 00 00 	ld ix, $0000
42    020F  FD 21 00 00 	ld iy, $0000
43    0213              
44    0213  ED 57       	ld	a, i			; cold boot/hard reset would init I to $00
45    0215  FE 00       	cp	a, $00			; is I zero?
46    0217  20 10       	jr  nz, resetWarm	; nope - warm boot
47    0219              
48    0219              	; initialze ram
49    0219  21 FF FF    	ld hl, $FFFF						; hard-coded ram top (64k)
50    021C  AF          	xor a								; memory page $00
51    021D  22 41 00    	ld (bios_var_ram_top), hl			; init bios vars
52    0220  32 43 00    	ld (bios_var_ram_active_page), a	; init to first page
53    0223              
54    0223              	; !! TEMP !!
55    0223              	;ld hl, bios_memory_page_size	; start of program memory (first page is reserved)
56    0223              	;call bios_memory_init			; call routine to clear/fill program memory
57    0223              
58    0223              	; initialize Interrupt mode
59    0223  3E 01       	ld	a, isr_table_index      ; load I with page address for isr_vector_table
60    0225  ED 47       	ld	i, a			        ; for the ISR jump table (at $0100)
61    0227  ED 5E       	im	2				        ; for IM2
62    0229              
63    0229              ; bios_reset_init jumps here if it detects a warm reset
64    0229              .resetWarm
65    0229              	; TODO reset all registers (except I and R)
66    0229  2A 41 00    	ld hl, (bios_var_ram_top)	; load ram-top
67    022C  F9          	ld sp, hl					; Stack Pointer at Ram Top
68    022D              
69    022D  FB          	ei					; turn on interrupts
70    022E  C3 8A 00    	jp __Start			; jmp to C main entry point
71    0231              
72    0231              
73    0231              
74    0231              
75    0231              
76    0231              
77    0231              
628   0231                 include "startup/debug.asm"
1     0231              ;
2     0231              ; debug routines
3     0231              ;
4     0231              
5     0231              ;ifdef DEBUG
6     0231              
7     0231              public debug_infopoint
8     0231              public debug_save_registers
9     0231              ;public debug_restore_registers
10    0231              ;public debug_restore_registers_all
11    0231              
12    0231              section zalt_debug
13    0000              
14    0000              ; IO port on the SystemController that is used for debug InfoPoints
15    0000              defc	debug_system_controller_port	=	$00
16    0000              
17    0000              ; (2 sets of 4 regs + 2 index regs and 2 cpu regs) times 2 bytes (24 bytes total)
18    0000              defc	debug_vars_size	= 24
19    0000              
20    0000              ; allocate space for debug vars
21    0000              debug_vars:
22    0000  18 00       defb debug_vars_size, $00
23    0002              
24    0002              defc	debug_var_base	=	debug_vars
25    0002              defc	debug_var_af	=	debug_var_base	+	$00
26    0002              defc	debug_var_bc	=	debug_var_base	+	$02
27    0002              defc	debug_var_de	=	debug_var_base	+	$04
28    0002              defc	debug_var_hl	=	debug_var_base	+	$06
29    0002              defc	debug_var_ix	=	debug_var_base	+	$08
30    0002              defc	debug_var_iy	=	debug_var_base	+	$0A
31    0002              defc	debug_var_sp	=	debug_var_base	+	$0C
32    0002              defc	debug_var_pc	=	debug_var_base	+	$0E
33    0002              defc	debug_var_af2	=	debug_var_base	+	$10
34    0002              defc	debug_var_bc2	=	debug_var_base	+	$12
35    0002              defc	debug_var_de2	=	debug_var_base	+	$14
36    0002              defc	debug_var_hl2	=	debug_var_base	+	$18
37    0002              
38    0002              
39    0002              ; Saves all registers in debug vars.
40    0002              ; Corrects for calling this sub-routine. So SP is saved as if before this call.
41    0002              ; pre-condition:
42    0002              ;	call-ret
43    0002              ; post-condition:
44    0002              ;	All registers retain their values (alternates also).
45    0002              debug_save_registers:
46    0002              	; bc, de and hl
47    0002  ED 43 00 00 	ld (debug_var_bc), bc	; store bc
48    0006  ED 53 00 00 	ld (debug_var_de), de	; store de
49    000A  22 00 00    	ld (debug_var_hl), hl	; store hl
50    000D  D9          	exx						; switch to alternate registers
51    000E  ED 43 00 00 	ld (debug_var_bc2), bc	; store bc'
52    0012  ED 53 00 00 	ld (debug_var_de2), de	; store de'
53    0016  22 00 00    	ld (debug_var_hl2), hl	; store hl'
54    0019  D9          	exx						; switch back
55    001A  DD 22 00 00 	ld (debug_var_ix), ix	; store ix
56    001E  FD 22 00 00 	ld (debug_var_iy), iy	; store iy
57    0022              	; pc
58    0022  E3          	ex (sp), hl				; swap hl onto the stack and get return address (pc)
59    0023  22 00 00    	ld (debug_var_pc), hl	; store pc
60    0026              	; sp
61    0026  E1          	pop hl					; sp is now as before when we were called
62    0027  ED 73 00 00 	ld (debug_var_sp), sp	; store sp
63    002B  2A 00 00    	ld hl, (debug_var_pc)	; load saved pc
64    002E  E5          	push hl					; restore return address
65    002F              	; af
66    002F  F5          	push af					; ld hl, af
67    0030  E1          	pop hl
68    0031  22 00 00    	ld (debug_var_af), hl	; store af
69    0034              	; af'
70    0034  08          	ex af, af				; switch to alternate af
71    0035  F5          	push af					; ld hl, af
72    0036  E1          	pop hl
73    0037  22 00 00    	ld (debug_var_af2), hl	; store af'
74    003A  08          	ex af, af				; switch af back
75    003B  2A 00 00    	ld hl, (debug_var_hl)	; restore hl value
76    003E  C9          	ret
77    003F              
78    003F              
79    003F              ; Restores all registers (incl. alternates) to saved values (debug_save_registers).
80    003F              ; ALSO RESTORES PC AND SP!
81    003F              ; THIS MEANS THAT THE RETURN ADDRESS IS CHANGED TO THE SAVED PC VALUE!!
82    003F              ; AND THE SP IS ALSO RESTORED TO THE SAVED VALUE!!
83    003F              debug_restore_registers_all:
84    003F  ED 7B 00 00 	ld sp, (debug_var_sp)	; load saved sp value
85    0043  2A 00 00    	ld hl, (debug_var_pc)	; load the saved pc value
86    0046  E5          	push hl					; set as new return address
87    0047              
88    0047              	; ... and we're doomed
89    0047              
90    0047              	; VVVVV fall thru! VVVVV
91    0047              
92    0047              ; Restores all registers (incl. alternates) to saved values (debug_save_registers).
93    0047              ; Does not restore pc and sp!
94    0047              debug_restore_registers:
95    0047              	; af'
96    0047  08          	ex af, af
97    0048  2A 00 00    	ld hl, (debug_var_af2)
98    004B  E5          	push hl
99    004C  F1          	pop af
100   004D              
101   004D              	; af
102   004D  08          	ex af, af
103   004E  2A 00 00    	ld hl, (debug_var_af)
104   0051  E5          	push hl
105   0052  F1          	pop af
106   0053              
107   0053              	; bc', de', hl'
108   0053  D9          	exx
109   0054  2A 00 00    	ld hl, (debug_var_bc2)
110   0057  44          	ld b, h
111   0058  4D          	ld c, l
112   0059  2A 00 00    	ld hl, (debug_var_de2)
113   005C  54          	ld d, h
114   005D  5D          	ld e, l
115   005E  2A 00 00    	ld hl, (debug_var_hl2)
116   0061              
117   0061              	; bc, de, hl
118   0061  D9          	exx
119   0062  2A 00 00    	ld hl, (debug_var_bc)
120   0065  44          	ld b, h
121   0066  4D          	ld c, l
122   0067  2A 00 00    	ld hl, (debug_var_de)
123   006A  54          	ld d, h
124   006B  5D          	ld e, l
125   006C  2A 00 00    	ld hl, (debug_var_hl)
126   006F              
127   006F              	; ix and iy
128   006F  DD 2A 00 00 	ld ix, (debug_var_ix)
129   0073  FD 2A 00 00 	ld iy, (debug_var_iy)
130   0077  C9          	ret
131   0078              
132   0078              
133   0078              ; Communicates with the System Controller to relay the information that makes up an InfoPoint.
134   0078              ; Mainly CPU-register values. debug_save_registers must be called first.
135   0078              ; The SystemController can halt (BUSREQ) the CPU in order to retrieve data from memory (DMA).
136   0078              debug_infopoint:
137   0078  01 00 00    	ld bc, debug_system_controller_port	; set io port
138   007B              
139   007B              	; for now we only check for no-command (zero)
140   007B  ED 78       	in a, (c)							; ask system controller if we're debugging
141   007D              ;	ret z								; exit if not so
142   007D              
143   007D              	; prepare to dump registers
144   007D  1E 18       	ld e, debug_vars_size				; size of register value block
145   007F  21 00 00    	ld hl, debug_vars					; start address of register value block
146   0082              
147   0082              .debug_infopoint_loop
148   0082  7E          	ld a, (hl)
149   0083  ED 79       	out (c), a
150   0085  23          	inc hl
151   0086  1D          	dec e
152   0087  20 F9       	jr nz, debug_infopoint_loop
153   0089              
154   0089  C9          	ret
155   008A              
156   008A              ;endif	; DEBUG
157   008A              
629   008A              
630   008A              ;**************************************************************
631   008A              ENDIF
632   008A              ;**************************************************************
633   008A              
634   008A              __Start:
635   008A                 ; parse command line
636   008A                 ; (optional)
637   008A              
638   008A                 ; initialize data section
639   008A                 include "../clib_init_data.inc"
1     008A              
2     008A                 ; initialize data section
3     008A                 ; data section is always at least one byte
4     008A              
5     008A                 IF (__crt_model = 1)
6     008A              
7     008A                    ; rom model + data section is not compressed
8     008A              
9     008A                    EXTERN __CODE_END_head
10    008A                    EXTERN __DATA_head, __DATA_END_tail
11    008A              
12    008A                    ld hl,__CODE_END_head
13    008A                    ld de,__DATA_head
14    008A                    ld bc,__DATA_END_tail - __DATA_head
15    008A              
16    008A                    ldir
17    008A              
18    008A                 ENDIF
19    008A              
20    008A                 IF (__crt_model >= 2)
21    008A              
22    008A                    ; rom model + data section is compressed
23    008A              
24    008A                    EXTERN __CODE_END_head, __DATA_head
25    008A              
26    008A                    ld hl,__CODE_END_head
27    008A                    ld de,__DATA_head
28    008A              
29    008A                    EXTERN asm_dzx7_standard
30    008A                    call asm_dzx7_standard
31    008A              
32    008A                 ENDIF
33    008A              
640   008A              
641   008A                 ; initialize bss section
642   008A                 include "../clib_init_bss.inc"
1     008A              
2     008A                 ; initialize bss section
3     008A              
4     008A                 IF (__crt_model | __crt_initialize_bss)
5     008A              
6     008A                       EXTERN asm_memset
7     008A                       EXTERN __BSS_UNINITIALIZED_tail, __BSS_END_tail
8     008A              
9     008A                       ld hl,__BSS_UNINITIALIZED_tail
10    008A                       ld bc,__BSS_END_tail - __BSS_UNINITIALIZED_tail
11    008A              
12    008A                       ld e,0
13    008A                       call asm_memset
14    008A              
15    008A                 ENDIF
16    008A              
643   008A              
644   008A              SECTION code_crt_init          ; user and library initialization
645   0005              SECTION code_crt_main
646   0000              
647   0000                 ; call user program
648   0000  CD 00 00        call _main                  ; hl = return status
649   0003              
650   0003                 ; run registered exit() functions
651   0003                 IF __clib_exit_stack_size > 0
652   0003                    EXTERN asm_exit
653   0003  C3 00 00          jp asm_exit              ; exit function jumps to __Exit
654   0006                 ENDIF
655   0006              
656   0006              __Exit:
657   0006                 ; abort(), exit(), quickexit() can be called from anywhere
658   0006                 ; so the stack may be unbalanced here
659   0006  E5             push hl                     ; hl = return status
660   0007              
661   0007              SECTION code_crt_exit          ; user and library cleanup
662   0000              SECTION code_crt_return
663   0000              
664   0000                 ; close files
665   0000                 include "../clib_close.inc"
1     0000                 IF __crt_enable_close
2     0000              
3     0000                    ; close open files
4     0000              
5     0000                    ; TODO
6     0000              
7     0000                 ENDIF
8     0000              
666   0000              
667   0000  E1             pop hl                      ; hl = return status
668   0001              
669   0001                 ; exit program
670   0001              zalt_oblivian:
671   0001              IF DEBUG
672   0001                  halt
673   0001              ENDIF
674   0001  18 FE       	jr zalt_oblivian
675   0003              
676   0003              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
677   0003              ;; RUNTIME VARS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
678   0003              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
679   0003              
680   0003              SECTION BSS_UNINITIALIZED
681   0000              
682   0000              ; place any uninitialized data here (eg saved stack pointer)
683   0000              ; bss and data section initialization will not touch it
684   0000              
685   0000              include "../clib_variables.inc"
1     0000              
2     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
3     0000              ;; library variables ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
5     0000              
6     0000              IF __clib_balloc_table_size > 0
7     0000              
8     0000                 ; create balloc table
9     0000              
10    0000                 SECTION data_clib
11    0000                 SECTION data_alloc_balloc
12    0000              
13    0000                 PUBLIC __balloc_array
14    0000              
15    0000                 __balloc_array:             defw __balloc_table
16    0000              
17    0000                 SECTION bss_clib
18    0000                 SECTION bss_alloc_balloc
19    0000              
20    0000                 __balloc_table:             defs __clib_balloc_table_size * 2
21    0000              
22    0000              ENDIF
23    0000              
24    0000              IF __clib_malloc_heap_size = -1
25    0000              
26    0000                 ; place malloc heap between bss section and bottom of the stack
27    0000              
28    0000                 SECTION data_clib
29    0000                 SECTION data_alloc_malloc
30    0000              
31    0000                 PUBLIC __malloc_heap
32    0000              
33    0000                 EXTERN __BSS_END_tail
34    0000              
35    0000  00 00          __malloc_heap:              defw __BSS_END_tail
36    0002              
37    0002                 SECTION code_crt_init
38    0005              
39    0005  21 FF FF       ld hl,-1                    ; ensure sp == 0 is accepted
40    0008  39             add hl,sp                   ; hl = top of the stack
41    0009              
42    0009  11 00 00       ld de,__BSS_END_tail
43    000C              
44    000C  AF             xor a
45    000D  ED 52          sbc hl,de                   ; hl = space between top of stack and end of bss - 1
46    000F              
47    000F  DA 06 00       jp c, __Exit                ; if stack overlaps bss, this is a fatal error
48    0012              
49    0012  01 0E 02       ld bc,__crt_stack_size + 14 ; amount of space reserved by stack + minimum heap size - 1
50    0015  ED 42          sbc hl,bc                   ; hl = max heap size - 15
51    0017              
52    0017  DA 06 00       jp c, __Exit                ; if no room for heap, this is a fatal error
53    001A              
54    001A  01 0F 00       ld bc,15
55    001D  09             add hl,bc
56    001E              
57    001E  4D             ld c,l
58    001F  44             ld b,h                      ; bc = available heap size
59    0020              
60    0020  EB             ex de,hl                    ; hl = __BSS_END_tail = start of heap
61    0021              
62    0021                 EXTERN asm_heap_init
63    0021  CD 00 00       call asm_heap_init
64    0024              
65    0024              ENDIF
66    0024              
67    0024              IF __clib_malloc_heap_size > 14
68    0024              
69    0024                 ; create malloc heap in bss section
70    0024              
71    0024                 SECTION data_clib
72    0024                 SECTION data_alloc_malloc
73    0024              
74    0024                 PUBLIC __malloc_heap
75    0024              
76    0024                 __malloc_heap:              defw __malloc_block
77    0024              
78    0024                 SECTION bss_clib
79    0024                 SECTION bss_alloc_malloc
80    0024              
81    0024                 __malloc_block:             defs __clib_malloc_heap_size
82    0024              
83    0024                 SECTION code_crt_init
84    0024              
85    0024                 ld hl,__malloc_block
86    0024                 ld bc,__clib_malloc_heap_size
87    0024              
88    0024                 EXTERN asm_heap_init
89    0024                 call asm_heap_init
90    0024              
91    0024              ENDIF
92    0024              
93    0024                 ; create exit stack
94    0024              
95    0024                 SECTION bss_clib
96    0000                 SECTION bss_stdlib
97    0000              
98    0000                 PUBLIC __exit_stack
99    0000              
100   0000  00             __exit_stack:               defb 0
101   0001  00 00 00 00                                defs __exit_stack_size * 2
102   0005              
103   0005                 ; create quickexit stack
104   0005              
105   0005                 SECTION bss_clib
106   0000                 SECTION bss_stdlib
107   0005              
108   0005                 PUBLIC __quickexit_stack
109   0005              
110   0005  00             __quickexit_stack:          defb 0
111   0006                                             defs __quickexit_stack_size * 2
112   0006              
113   0006                 ; assign thread id
114   0006              
115   0006                 SECTION data_clib
116   0000                 SECTION data_threads
117   0000              
118   0000                 PUBLIC __thrd_id
119   0000              
120   0000  01             __thrd_id:                  defb 1
121   0001              
122   0001              ;; end library variables ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
123   0001              
686   0001              include "clib_target_variables.inc"
1     0001              
2     0001              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
3     0001              ;; target variables ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4     0001              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
5     0001              
6     0001              ;; end target variables ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
7     0001              
687   0001              
688   0001              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
689   0001              ;; CLIB STUBS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
690   0001              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
691   0001              
692   0001              include "../clib_stubs.inc"
1     0001              
2     0001                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
3     0001                 ;; unimplemented
4     0001                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
5     0001              
6     0001                 ; system()
7     0001              
8     0001                 PUBLIC __ch_system
9     0001              
10    0001                 EXTERN error_zc
11    0001              
12    0001                 defc __ch_system = error_zc
13    0001              
14    0001                 ; threads
15    0001                 ; these functions are preliminary only
16    0001              
17    0001                 PUBLIC __thread_context_switch
18    0001                 PUBLIC __thread_block_timeout
19    0001                 PUBLIC __thread_unblock
20    0001              
21    0001                 EXTERN l_ret
22    0001              
23    0001                 defc __thread_context_switch = l_ret
24    0001                 defc __thread_block_timeout  = l_ret
25    0001                 defc __thread_unblock        = l_ret
26    0001              
27    0001                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
28    0001                 ;; dynamically generated functions
29    0001                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
30    0001              
31    0001                 IF !DEFINED_CLIB_OPT_STDIO
32    0001                    defc DEFINED_CLIB_OPT_STDIO = 1
33    0001                    defc CLIB_OPT_STDIO = 0
34    0001                 ENDIF
35    0001              
36    0001                 defc __CLIB_OPT_STDIO = CLIB_OPT_STDIO
37    0001              
38    0001                 ; dynamic printf
39    0001              
40    0001                 IF DEFINED_CLIB_OPT_PRINTF
41    0001                    IF !DEFINED_CLIB_OPT_PRINTF_2
42    0001                       defc DEFINED_CLIB_OPT_PRINTF_2 = 1
43    0001                       defc CLIB_OPT_PRINTF_2 = 0
44    0001                    ENDIF
45    0001                 ENDIF
46    0001              
47    0001                 IF DEFINED_CLIB_OPT_PRINTF_2
48    0001                    IF !DEFINED_CLIB_OPT_PRINTF
49    0001                       defc DEFINED_CLIB_OPT_PRINTF = 1
50    0001                       defc CLIB_OPT_PRINTF = 0
51    0001                    ENDIF
52    0001                 ENDIF
53    0001              
54    0001                 IF DEFINED_CLIB_OPT_PRINTF
55    0001              
56    0001                    defc __CLIB_OPT_PRINTF = CLIB_OPT_PRINTF
57    0001                    defc __CLIB_OPT_PRINTF_2 = CLIB_OPT_PRINTF_2
58    0001              
59    0001                    IF __SDCC_IY
60    0001              
61    0001                       INCLUDE "../../stdio/z80/asm_vfprintf_unlocked_iy.asm"
62    0001              
63    0001                    ELSE
64    0001              
65    0001                       INCLUDE "../../stdio/z80/asm_vfprintf_unlocked.asm"
66    0001              
67    0001                    ENDIF
68    0001              
69    0001                 ENDIF
70    0001              
71    0001                 ; dynamic scanf
72    0001              
73    0001                 IF DEFINED_CLIB_OPT_SCANF
74    0001                    IF !DEFINED_CLIB_OPT_SCANF_2
75    0001                       defc DEFINED_CLIB_OPT_SCANF_2 = 1
76    0001                       defc CLIB_OPT_SCANF_2 = 0
77    0001                    ENDIF
78    0001                 ENDIF
79    0001              
80    0001                 IF DEFINED_CLIB_OPT_SCANF_2
81    0001                    IF !DEFINED_CLIB_OPT_SCANF
82    0001                       defc DEFINED_CLIB_OPT_SCANF = 1
83    0001                       defc CLIB_OPT_SCANF = 0
84    0001                    ENDIF
85    0001                 ENDIF
86    0001              
87    0001                 IF DEFINED_CLIB_OPT_SCANF
88    0001              
89    0001                    defc __CLIB_OPT_SCANF = CLIB_OPT_SCANF
90    0001                    defc __CLIB_OPT_SCANF_2 = CLIB_OPT_SCANF_2
91    0001              
92    0001                    IF __SDCC_IY
93    0001              
94    0001                       INCLUDE "../../stdio/z80/asm_vfscanf_unlocked_iy.asm"
95    0001              
96    0001                    ELSE
97    0001              
98    0001                       INCLUDE "../../stdio/z80/asm_vfscanf_unlocked.asm"
99    0001              
100   0001                    ENDIF
101   0001              
102   0001                 ENDIF
103   0001              
693   0001              
47    0001              
48    0001              ENDIF
49    0001              
