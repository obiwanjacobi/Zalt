1     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2     0000              ; SELECT CRT0 FROM -STARTUP=N COMMANDLINE OPTION ;;;;;;;;;;;;;;
3     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4     0000              
5     0000              INCLUDE "zcc_opt.def"
1     0000              
2     0000              IF !DEFINED_Z88DK_USES_SDCC
3     0000              	defc	DEFINED_Z88DK_USES_SDCC = 1
4     0000              	defc Z88DK_USES_SDCC = 1
5     0000              	IFNDEF Z88DK_USES_SDCC
6     0000              	ENDIF
7     0000              ENDIF
8     0000              
9     0000              
6     0000              
7     0000              IFNDEF startup
8     0000              
9     0000                 ; startup undefined so select a default
10    0000              
11    0000                 defc startup = 0
12    0000              
13    0000              ENDIF
14    0000              
15    0000              
16    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
17    0000              ;; user supplied crt ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
18    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
19    0000              
20    0000              IF startup = -1
21    0000              
22    0000                 INCLUDE "crt.asm"
23    0000              
24    0000              ENDIF
25    0000              
26    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
27    0000              ;; ram model ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
28    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
29    0000              
30    0000              IF startup = 0
31    0000              
32    0000                 ; generic zalt startup
33    0000              
34    0000                 IFNDEF __CRTDEF
35    0000              
36    0000                    defc __CRTDEF = 0
37    0000              
38    0000                 ENDIF
39    0000              
40    0000                 IFNDEF __MMAP
41    0000              
42    0000                    defc __MMAP = 0
43    0000              
44    0000                 ENDIF
45    0000              
46    0000                 INCLUDE "startup/zalt_crt_0.asm"
1     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2     0000              ;;                  zalt standalone target                   ;;
3     0000              ;;    generated by target/zalt/startup/zalt_crt_0.asm.m4     ;;
4     0000              ;;                                                           ;;
5     0000              ;;                  flat 64k address space*                  ;;
6     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
7     0000              ; *) for now
8     0000              
9     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
10    0000              ;; CRT AND CLIB CONFIGURATION ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
11    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
12    0000              
13    0000              include "../crt_defaults.inc"
1     0000              
2     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
3     0000              ;; crt defaults ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
5     0000              
6     0000                 ; crt configuration
7     0000              
8     0000                 defc DEF__crt_org_code              = 0       ;; org of code section
9     0000                 defc DEF__crt_org_data              = 0       ;; org of data section (0 or -1 means follow code, -1 means generate separate binary)
10    0000                 defc DEF__crt_org_bss               = 0       ;; org of bss section (0 or -1 means follow data, -1 means generate separate binary)
11    0000              
12    0000                 defc DEF__crt_model                 = 0       ;; 0 = ram model, 1 = rom model, 2 = compressed rom model
13    0000              
14    0000                 defc DEF__register_sp               = 0       ;; initial value of sp (-1 = do not modify (some targets may redefine meaning), 0 = top of memory)
15    0000                 defc DEF__crt_stack_size            = 512     ;; minimum size reserved for stack when automatically allocating memory for the malloc heap
16    0000              
17    0000                 defc DEF__crt_initialize_bss        = 0       ;; generate code to initialize bss section at startup (only applicable if ram model in use)
18    0000              
19    0000                 defc DEF__crt_include_preamble      = 0       ;; if non-zero, user supplies code in file "crt_preamble.asm" that is inserted at the start of the binary
20    0000              
21    0000                 defc DEF__crt_enable_streams        = 0x7     ;; set bit enables stream, stdin/stdout/stderr enabled
22    0000              
23    0000                 defc DEF__crt_enable_commandline    = 2       ;; generate argc and argv from command line (targets without command line will get argc=1, argv[0]="", argv[1]=NULL)
24    0000                 defc DEF__crt_enable_restart        = 0       ;; if non-zero, restart the program on exit (correct initialization of static variables with rom models only)
25    0000                 defc DEF__crt_enable_close          = 1       ;; if non-zero, close files on exit
26    0000              
27    0000                 defc DEF__crt_enable_eidi           = 0       ;; bit flags: 0x01 = di on restart, 0x02 = ei on restart, 0x10 = di on exit, 0x20 = ei on exit
28    0000                 defc DEF__crt_on_exit               = 0x10001 ;; halt on exit (see documentation for other exit behaviours)
29    0000              
30    0000                 defc DEF__crt_enable_rst            = 0       ;; if non-zero and in some crts with code org = 0, set bits indicate which rst locations are implemented with user code
31    0000                 defc DEF__crt_enable_nmi            = 0       ;; if non-zero and in some crts with code org = 0, a jump to user code to service the nmi is inserted
32    0000              
33    0000                 ; clib defaults
34    0000              
35    0000                 defc DEF__clib_exit_stack_size      = 32      ;; max number of functions that can be registered with atexit()
36    0000                 defc DEF__clib_quickexit_stack_size = 32      ;; max number of functions that can be registered with at_quickexit()
37    0000              
38    0000                 defc DEF__clib_malloc_heap_size     = -1      ;; size of malloc heap (0 = do not create a heap, -1 = automatically place heap between end of bss section and bottom of stack)
39    0000                 defc DEF__clib_stdio_heap_size      = 256     ;; size of stdio heap (0 = do not allocate bytes for opening of files)
40    0000              
41    0000                 defc DEF__clib_balloc_table_size    = 0       ;; number of queues created for balloc block memory allocator
42    0000              
43    0000                 defc DEF__clib_fopen_max            = 8       ;; max number of FILE* (-1 = do not create list of open FILE* (only effective if no stdin/stdout/stderr))
44    0000                 defc DEF__clib_open_max             = 8       ;; max number of open files
45    0000              
46    0000              ;; end crt defaults ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
47    0000              
14    0000              include "crt_target_defaults.inc"
1     0000              
2     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
3     0000              ;; crt target defaults ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
5     0000              
6     0000              IF __CRTDEF = -1
7     0000              
8     0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
9     0000                 ;; user supplied crt defaults ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
10    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
11    0000              
12    0000                 INCLUDE "crtdef.inc"
13    0000              
14    0000              ENDIF
15    0000              
16    0000              IF __CRTDEF = 0
17    0000              
18    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
19    0000                 ;; zalt ram model ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
20    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
21    0000              
22    0000                 defc TAR__crt_org_code              = 0 ; was 32768!
23    0000                 defc TAR__crt_org_data              = 0
24    0000                 defc TAR__crt_org_bss               = 0
25    0000              
26    0000                 defc TAR__crt_model                 = 0
27    0000              
28    0000                 defc TAR__register_sp               = 0
29    0000                 defc TAR__crt_stack_size            = 512
30    0000              
31    0000                 defc TAR__crt_initialize_bss        = 0
32    0000              
33    0000                 defc TAR__crt_enable_commandline    = 0
34    0000                 defc TAR__crt_enable_restart        = 0
35    0000                 defc TAR__crt_enable_close          = 1
36    0000              
37    0000                 defc TAR__crt_enable_rst            = 0
38    0000                 defc TAR__crt_enable_nmi            = 0
39    0000              
40    0000                 ; clib defaults
41    0000              
42    0000                 defc TAR__clib_exit_stack_size      = 2
43    0000                 defc TAR__clib_quickexit_stack_size = 0
44    0000              
45    0000                 defc TAR__clib_malloc_heap_size     = -1
46    0000                 defc TAR__clib_stdio_heap_size      = 128
47    0000              
48    0000                 defc TAR__clib_balloc_table_size    = 0
49    0000              
50    0000                 defc TAR__clib_fopen_max            = 0
51    0000                 defc TAR__clib_open_max             = 0
52    0000              
53    0000              ENDIF
54    0000              
55    0000              ;; end crt target defaults ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
56    0000              
15    0000              include "../crt_rules.inc"
1     0000              
2     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
3     0000              ;; crt rules ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
5     0000              
6     0000              
7     0000                 IFDEF myzorg
8     0000              
9     0000                    defc __crt_org_code = myzorg
10    0000              
11    0000                 ELSE
12    0000              
13    0000                    IFDEF CRT_ORG_CODE
14    0000              
15    0000                       defc __crt_org_code = CRT_ORG_CODE
16    0000              
17    0000                    ELSE
18    0000              
19    0000                       IFDEF TAR__crt_org_code
20    0000              
21    0000                          defc __crt_org_code = TAR__crt_org_code
22    0000              
23    0000                       ELSE
24    0000              
25    0000                          defc __crt_org_code = DEF__crt_org_code
26    0000              
27    0000                       ENDIF
28    0000              
29    0000                    ENDIF
30    0000              
31    0000                    defc myzorg = __crt_org_code
32    0000              
33    0000                 ENDIF
34    0000              
35    0000              
36    0000                 IFDEF REGISTER_SP
37    0000              
38    0000                    defc __register_sp = REGISTER_SP
39    0000              
40    0000                 ELSE
41    0000              
42    0000                    IFDEF STACKPTR
43    0000              
44    0000                       defc __register_sp = STACKPTR
45    0000              
46    0000                    ELSE
47    0000              
48    0000                       IFDEF TAR__register_sp
49    0000              
50    0000                          defc __register_sp = TAR__register_sp
51    0000              
52    0000                       ELSE
53    0000              
54    0000                          defc __register_sp = DEF__register_sp
55    0000              
56    0000                       ENDIF
57    0000              
58    0000                    ENDIF
59    0000              
60    0000                 ENDIF
61    0000              
62    0000              
63    0000                 IFDEF CRT_STACK_SIZE
64    0000              
65    0000                    defc __crt_stack_size = CRT_STACK_SIZE
66    0000              
67    0000                 ELSE
68    0000              
69    0000                    IFDEF TAR__crt_stack_size
70    0000              
71    0000                       defc __crt_stack_size = TAR__crt_stack_size
72    0000              
73    0000                    ELSE
74    0000              
75    0000                       defc __crt_stack_size = DEF__crt_stack_size
76    0000              
77    0000                    ENDIF
78    0000              
79    0000                 ENDIF
80    0000              
81    0000              
82    0000                 IFDEF CRT_ORG_DATA
83    0000              
84    0000                    defc __crt_org_data = CRT_ORG_DATA
85    0000              
86    0000                 ELSE
87    0000              
88    0000                    IFDEF TAR__crt_org_data
89    0000              
90    0000                       defc __crt_org_data = TAR__crt_org_data
91    0000              
92    0000                    ELSE
93    0000              
94    0000                       defc __crt_org_data = DEF__crt_org_data
95    0000              
96    0000                    ENDIF
97    0000              
98    0000                 ENDIF
99    0000              
100   0000              
101   0000                 IFDEF CRT_ORG_BSS
102   0000              
103   0000                    defc __crt_org_bss = CRT_ORG_BSS
104   0000              
105   0000                 ELSE
106   0000              
107   0000                    IFDEF TAR__crt_org_bss
108   0000              
109   0000                       defc __crt_org_bss = TAR__crt_org_bss
110   0000              
111   0000                    ELSE
112   0000              
113   0000                       defc __crt_org_bss = DEF__crt_org_bss
114   0000              
115   0000                    ENDIF
116   0000              
117   0000                 ENDIF
118   0000              
119   0000              
120   0000                 IFDEF CRT_MODEL
121   0000              
122   0000                    defc __crt_model = CRT_MODEL
123   0000              
124   0000                 ELSE
125   0000              
126   0000                    IFDEF TAR__crt_model
127   0000              
128   0000                       defc __crt_model = TAR__crt_model
129   0000              
130   0000                    ELSE
131   0000              
132   0000                       defc __crt_model = DEF__crt_model
133   0000              
134   0000                    ENDIF
135   0000              
136   0000                 ENDIF
137   0000              
138   0000              
139   0000                 IFDEF CRT_INITIALIZE_BSS
140   0000              
141   0000                    defc __crt_initialize_bss = CRT_INITIALIZE_BSS
142   0000              
143   0000                 ELSE
144   0000              
145   0000                    IFDEF TAR__crt_initialize_bss
146   0000              
147   0000                       defc __crt_initialize_bss = TAR__crt_initialize_bss
148   0000              
149   0000                    ELSE
150   0000              
151   0000                       defc __crt_initialize_bss = DEF__crt_initialize_bss
152   0000              
153   0000                    ENDIF
154   0000              
155   0000                 ENDIF
156   0000              
157   0000              
158   0000                 IFDEF CRT_INCLUDE_PREAMBLE
159   0000              
160   0000                    defc __crt_include_preamble = CRT_INCLUDE_PREAMBLE
161   0000              
162   0000                 ELSE
163   0000              
164   0000                    IFDEF TAR__crt_include_preamble
165   0000              
166   0000                       defc __crt_include_preamble = TAR__crt_include_preamble
167   0000              
168   0000                    ELSE
169   0000              
170   0000                       defc __crt_include_preamble = DEF__crt_include_preamble
171   0000              
172   0000                    ENDIF
173   0000              
174   0000                 ENDIF
175   0000              
176   0000              
177   0000                 IFDEF CRT_ENABLE_STREAMS
178   0000              
179   0000                    defc __crt_enable_streams = CRT_ENABLE_STREAMS
180   0000              
181   0000                 ELSE
182   0000              
183   0000                    IFDEF TAR__crt_enable_streams
184   0000              
185   0000                       defc __crt_enable_streams = TAR__crt_enable_streams
186   0000              
187   0000                    ELSE
188   0000              
189   0000                       defc __crt_enable_streams = DEF__crt_enable_streams
190   0000              
191   0000                    ENDIF
192   0000              
193   0000                 ENDIF
194   0000              
195   0000              
196   0000                 IFDEF CRT_ENABLE_COMMANDLINE
197   0000              
198   0000                    defc __crt_enable_commandline = CRT_ENABLE_COMMANDLINE
199   0000              
200   0000                 ELSE
201   0000              
202   0000                    IFDEF TAR__crt_enable_commandline
203   0000              
204   0000                       defc __crt_enable_commandline = TAR__crt_enable_commandline
205   0000              
206   0000                    ELSE
207   0000              
208   0000                       defc __crt_enable_commandline = DEF__crt_enable_commandline
209   0000              
210   0000                    ENDIF
211   0000              
212   0000                 ENDIF
213   0000              
214   0000              
215   0000                 IFDEF CRT_ENABLE_RESTART
216   0000              
217   0000                    defc __crt_enable_restart = CRT_ENABLE_RESTART
218   0000              
219   0000                 ELSE
220   0000              
221   0000                    IFDEF TAR__crt_enable_restart
222   0000              
223   0000                       defc __crt_enable_restart = TAR__crt_enable_restart
224   0000              
225   0000                    ELSE
226   0000              
227   0000                       defc __crt_enable_restart = DEF__crt_enable_restart
228   0000              
229   0000                    ENDIF
230   0000              
231   0000                 ENDIF
232   0000              
233   0000              
234   0000                 IFDEF CRT_ENABLE_CLOSE
235   0000              
236   0000                    defc __crt_enable_close = CRT_ENABLE_CLOSE
237   0000              
238   0000                 ELSE
239   0000              
240   0000                    IFDEF TAR__crt_enable_close
241   0000              
242   0000                       defc __crt_enable_close = TAR__crt_enable_close
243   0000              
244   0000                    ELSE
245   0000              
246   0000                       defc __crt_enable_close = DEF__crt_enable_close
247   0000              
248   0000                    ENDIF
249   0000              
250   0000                 ENDIF
251   0000              
252   0000              
253   0000                 IFDEF CRT_ENABLE_EIDI
254   0000              
255   0000                    defc __crt_enable_eidi = CRT_ENABLE_EIDI
256   0000              
257   0000                 ELSE
258   0000              
259   0000                    IFDEF TAR__crt_enable_eidi
260   0000              
261   0000                       defc __crt_enable_eidi = TAR__crt_enable_eidi
262   0000              
263   0000                    ELSE
264   0000              
265   0000                       defc __crt_enable_eidi = DEF__crt_enable_eidi
266   0000              
267   0000                    ENDIF
268   0000              
269   0000                 ENDIF
270   0000              
271   0000              
272   0000                 IF __crt_enable_restart
273   0000              
274   0000                    defc __crt_on_exit = 0x10008
275   0000              
276   0000                 ELSE
277   0000              
278   0000                    IFDEF CRT_ON_EXIT
279   0000              
280   0000                       defc __crt_on_exit = CRT_ON_EXIT
281   0000              
282   0000                    ELSE
283   0000              
284   0000                       IFDEF TAR__crt_on_exit
285   0000              
286   0000                          defc __crt_on_exit = TAR__crt_on_exit
287   0000              
288   0000                       ELSE
289   0000              
290   0000                          defc __crt_on_exit = DEF__crt_on_exit
291   0000              
292   0000                       ENDIF
293   0000              
294   0000                    ENDIF
295   0000              
296   0000                 ENDIF
297   0000              
298   0000              
299   0000                 IFDEF CLIB_EXIT_STACK_SIZE
300   0000              
301   0000                    defc __clib_exit_stack_size = CLIB_EXIT_STACK_SIZE
302   0000              
303   0000                 ELSE
304   0000              
305   0000                    IFDEF TAR__clib_exit_stack_size
306   0000              
307   0000                       defc __clib_exit_stack_size = TAR__clib_exit_stack_size
308   0000              
309   0000                    ELSE
310   0000              
311   0000                       defc __clib_exit_stack_size = DEF__clib_exit_stack_size
312   0000              
313   0000                    ENDIF
314   0000              
315   0000                 ENDIF
316   0000              
317   0000              
318   0000                 IFDEF CLIB_QUICKEXIT_STACK_SIZE
319   0000              
320   0000                    defc __clib_quickexit_stack_size = CLIB_QUICKEXIT_STACK_SIZE
321   0000              
322   0000                 ELSE
323   0000              
324   0000                    IFDEF TAR__clib_quickexit_stack_size
325   0000              
326   0000                       defc __clib_quickexit_stack_size = TAR__clib_quickexit_stack_size
327   0000              
328   0000                    ELSE
329   0000              
330   0000                       defc __clib_quickexit_stack_size = DEF__clib_quickexit_stack_size
331   0000              
332   0000                    ENDIF
333   0000              
334   0000                 ENDIF
335   0000              
336   0000              
337   0000                 IFDEF CLIB_MALLOC_HEAP_SIZE
338   0000              
339   0000                    defc __clib_malloc_heap_size = CLIB_MALLOC_HEAP_SIZE
340   0000              
341   0000                 ELSE
342   0000              
343   0000                    IFDEF TAR__clib_malloc_heap_size
344   0000              
345   0000                       defc __clib_malloc_heap_size = TAR__clib_malloc_heap_size
346   0000              
347   0000                    ELSE
348   0000              
349   0000                       defc __clib_malloc_heap_size = DEF__clib_malloc_heap_size
350   0000              
351   0000                    ENDIF
352   0000              
353   0000                 ENDIF
354   0000              
355   0000              
356   0000                 IFDEF CLIB_STDIO_HEAP_SIZE
357   0000              
358   0000                    defc __clib_stdio_heap_size = CLIB_STDIO_HEAP_SIZE
359   0000              
360   0000                 ELSE
361   0000              
362   0000                    IFDEF TAR__clib_stdio_heap_size
363   0000              
364   0000                       defc __clib_stdio_heap_size = TAR__clib_stdio_heap_size
365   0000              
366   0000                    ELSE
367   0000              
368   0000                       defc __clib_stdio_heap_size = DEF__clib_stdio_heap_size
369   0000              
370   0000                    ENDIF
371   0000              
372   0000                 ENDIF
373   0000              
374   0000              
375   0000                 IFDEF CLIB_BALLOC_TABLE_SIZE
376   0000              
377   0000                    defc __clib_balloc_table_size = CLIB_BALLOC_TABLE_SIZE
378   0000              
379   0000                 ELSE
380   0000              
381   0000                    IFDEF TAR__clib_balloc_table_size
382   0000              
383   0000                       defc __clib_balloc_table_size = TAR__clib_balloc_table_size
384   0000              
385   0000                    ELSE
386   0000              
387   0000                       defc __clib_balloc_table_size = DEF__clib_balloc_table_size
388   0000              
389   0000                    ENDIF
390   0000              
391   0000                 ENDIF
392   0000              
393   0000              
394   0000                 IFDEF CLIB_FOPEN_MAX
395   0000              
396   0000                    defc __clib_fopen_max = CLIB_FOPEN_MAX
397   0000              
398   0000                 ELSE
399   0000              
400   0000                    IFDEF TAR__clib_fopen_max
401   0000              
402   0000                       defc __clib_fopen_max = TAR__clib_fopen_max
403   0000              
404   0000                    ELSE
405   0000              
406   0000                       defc __clib_fopen_max = DEF__clib_fopen_max
407   0000              
408   0000                    ENDIF
409   0000              
410   0000                 ENDIF
411   0000              
412   0000              
413   0000                 IFDEF CLIB_OPEN_MAX
414   0000              
415   0000                    defc __clib_open_max = CLIB_OPEN_MAX
416   0000              
417   0000                 ELSE
418   0000              
419   0000                    IFDEF TAR__clib_open_max
420   0000              
421   0000                       defc __clib_open_max = TAR__clib_open_max
422   0000              
423   0000                    ELSE
424   0000              
425   0000                       defc __clib_open_max = DEF__clib_open_max
426   0000              
427   0000                    ENDIF
428   0000              
429   0000                 ENDIF
430   0000              
431   0000              
432   0000                 IFDEF CRT_ENABLE_RST
433   0000              
434   0000                    defc __crt_enable_rst = CRT_ENABLE_RST
435   0000              
436   0000                 ELSE
437   0000              
438   0000                    IFDEF TAR__crt_enable_rst
439   0000              
440   0000                       defc __crt_enable_rst = TAR__crt_enable_rst
441   0000              
442   0000                    ELSE
443   0000              
444   0000                       defc __crt_enable_rst = DEF__crt_enable_rst
445   0000              
446   0000                    ENDIF
447   0000              
448   0000                 ENDIF
449   0000              
450   0000              
451   0000                 IFDEF CRT_ENABLE_NMI
452   0000              
453   0000                    defc __crt_enable_nmi = CRT_ENABLE_NMI
454   0000              
455   0000                 ELSE
456   0000              
457   0000                    IFDEF TAR__crt_enable_nmi
458   0000              
459   0000                       defc __crt_enable_nmi = TAR__crt_enable_nmi
460   0000              
461   0000                    ELSE
462   0000              
463   0000                       defc __crt_enable_nmi = DEF__crt_enable_nmi
464   0000              
465   0000                    ENDIF
466   0000              
467   0000                 ENDIF
468   0000              
469   0000              
470   0000                 ;; public definitions
471   0000              
472   0000                 PUBLIC __exit_stack_size
473   0000                 PUBLIC __quickexit_stack_size
474   0000              
475   0000                 defc __exit_stack_size = __clib_exit_stack_size
476   0000                 defc __quickexit_stack_size = __clib_quickexit_stack_size
477   0000              
478   0000              ;; end crt rules ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
479   0000              
16    0000              
17    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
18    0000              ;; SET UP MEMORY MODEL ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
19    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
20    0000              
21    0000              include "memory_model.inc"
1     0000              
2     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
3     0000              ;; memory model ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
5     0000              
6     0000              IF __MMAP = -1
7     0000              
8     0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
9     0000                 ;; user supplied memory map ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
10    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
11    0000              
12    0000                 INCLUDE "mmap.inc"
13    0000              
14    0000              ENDIF
15    0000              
16    0000              IF __MMAP = 0
17    0000              
18    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
19    0000                 ;; standard CODE/DATA/BSS memory map ;;;;;;;;;;;;;;;;;;;;;;;
20    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
21    0000              
22    0000                 ;;INCLUDE "../crt_memory_model.inc"
23    0000              
24    0000              
25    0000              
26    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
27    0000              ;; memory model ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
28    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
29    0000              
30    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
31    0000              
32    0000              SECTION CODE
33    0000              
34    0000              org __crt_org_code
35    0000              
36    0000              section code_crt_init
37    0000              section code_crt_main
38    0000              section code_crt_exit
39    0000              section code_crt_return
40    0000              section code_crt_common
41    0000              
42    0000              ; zalt
43    0000              section zalt_system
44    0000              section zalt_lib
45    0000              
46    0000              section code_driver
47    0000              section code_font
48    0000              section code_clib
49    0000                include "../../clib_code.inc"
1     0000              
2     0000              ;; clib code segments ;;;;;;;;;
3     0000              
4     0000              section code_adt_b_array
5     0000              section code_adt_b_vector
6     0000              section code_adt_ba_priority_queue
7     0000              section code_adt_ba_stack
8     0000              section code_adt_bv_priority_queue
9     0000              section code_adt_bv_stack
10    0000              section code_adt_p_forward_list
11    0000              section code_adt_p_forward_list_alt
12    0000              section code_adt_p_list
13    0000              section code_adt_p_queue
14    0000              section code_adt_p_stack
15    0000              section code_adt_w_array
16    0000              section code_adt_w_vector
17    0000              section code_adt_wa_priority_queue
18    0000              section code_adt_wa_stack
19    0000              section code_adt_wv_priority_queue
20    0000              section code_adt_wv_stack
21    0000              section code_alloc_balloc
22    0000              section code_alloc_malloc
23    0000              section code_alloc_obstack
24    0000              section code_arch
25    0000              section code_bifrost_h
26    0000              section code_bifrost_l
27    0000              section code_bifrost2
28    0000              section code_compress_aplib
29    0000              section code_compress_zx7
30    0000              section code_ctype
31    0000              section code_driver_general
32    0000              section code_driver_character_input
33    0000              section code_driver_character_output
34    0000              section code_driver_memstream
35    0000              section code_driver_terminal_input
36    0000              section code_driver_terminal_output
37    0000              section code_driver_tty
38    0000              section code_error
39    0000              section code_fcntl
40    0000              section code_font_fzx
41    0000              section code_fp_genmath
42    0000              section code_fp_math48
43    0000              section code_input
44    0000              section code_inttypes
45    0000              section code_l
46    0000              section code_l_sccz80
47    0000              section code_l_sdcc
48    0000              section code_locale
49    0000              section code_math
50    0000              section code_network
51    0000              section code_nirvanam
52    0000              section code_nirvanap
53    0000              section code_setjmp
54    0000              section code_sound_bit
55    0000              section code_stdio
56    0000              section code_stdlib
57    0000              section code_string
58    0000              section code_temp_sp1
59    0000              section code_threads
60    0000              section code_threads_mutex
61    0000              section code_z80
62    0000              
63    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
64    0000              
50    0000              section code_lib
51    0000              section code_compiler
52    0000              section code_user
53    0000              
54    0000              section rodata_driver
55    0000              section rodata_font
56    0000              section rodata_clib
57    0000                include "../../clib_rodata.inc"
1     0000              
2     0000              ;; clib rodata segments ;;;;;;;
3     0000              
4     0000              section rodata_error_strings
5     0000              section rodata_error_string_end
6     0000  00          defb 0
7     0001              section rodata_fcntl
8     0000              section rodata_font_4x8
9     0000              section rodata_font_8x8
10    0000              section rodata_font_fzx
11    0000              section rodata_input
12    0000              section rodata_sound_bit
13    0000              section rodata_stdio
14    0000              section rodata_stdlib
15    0000              
16    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
17    0000              
58    0000                ;;section rodata_error_strings
59    0000                ;;section rodata_error_string_end
60    0000                ;;defb 0
61    0000              section rodata_lib
62    0000              section rodata_compiler
63    0000              section rodata_user
64    0000              
65    0000              SECTION CODE_END
66    0000              
67    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
68    0000              
69    0000              SECTION DATA
70    0000              
71    0000              IF __crt_org_data
72    0000              
73    0000                 org __crt_org_data
74    0000              
75    0000              ELSE
76    0000              
77    0000                 IF __crt_model
78    0000              
79    0000                    "DATA section address must be specified for rom models"
80    0000              
81    0000                 ENDIF
82    0000              
83    0000              ENDIF
84    0000              
85    0000  00          defb 0
86    0001              
87    0001              section smc_driver
88    0000              section smc_font
89    0000              section smc_clib
90    0000                include "../../clib_smc.inc"
1     0000              
2     0000              ;; clib self-modifying code ;;;
3     0000              
4     0000              section smc_fcntl
5     0000              section smc_l
6     0000              section smc_sound_bit
7     0000              
8     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
9     0000              
91    0000              section smc_lib
92    0000              section smc_compiler
93    0000              section smc_user
94    0000              
95    0000              section data_driver
96    0000              section data_font
97    0000              section data_clib
98    0000                include "../../clib_data.inc"
1     0000              
2     0000              ;; clib data segments ;;;;;;;;;
3     0000              
4     0000              section data_alloc_balloc
5     0000              section data_alloc_malloc
6     0000              section data_fcntl
7     0000              section data_fcntl_stdio_heap_head
8     0000              section data_fcntl_stdio_heap_body
9     0000              section data_fcntl_stdio_heap_tail
10    0000              section data_fcntl_fdtable_body
11    0000              section data_sound_bit
12    0000              section data_stdio
13    0000              section data_stdlib
14    0000              section data_threads
15    0000              
16    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
17    0000              
99    0000                ;;section data_fcntl_stdio_heap_head
100   0000                ;;section data_fcntl_stdio_heap_body
101   0000                ;;section data_fcntl_stdio_heap_tail
102   0000                ;;section data_fcntl_fdtable_body
103   0000              section data_lib
104   0000              section data_compiler
105   0000              section data_user
106   0000              
107   0000              SECTION DATA_END
108   0000              
109   0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
110   0000              
111   0000              SECTION BSS
112   0000              
113   0000              IF __crt_org_bss
114   0000              
115   0000                 org __crt_org_bss
116   0000              
117   0000              ELSE
118   0000              
119   0000                 IF __crt_model
120   0000              
121   0000                    org -1
122   0000              
123   0000                 ENDIF
124   0000              
125   0000              ENDIF
126   0000              
127   0000  00          defb 0
128   0001              
129   0001              section BSS_UNINITIALIZED
130   0000              
131   0000              section bss_driver
132   0000              section bss_font
133   0000              section bss_clib
134   0000                include "../../clib_bss.inc"
1     0000              
2     0000              ;; clib bss segments ;;;;;;;;;;
3     0000              
4     0000              section bss_arch
5     0000              section bss_alloc_balloc
6     0000              section bss_alloc_malloc
7     0000              section bss_compress_aplib
8     0000              section bss_error
9     0000              section bss_fcntl
10    0000              section bss_input
11    0000              section bss_sound_bit
12    0000              section bss_stdio
13    0000              section bss_stdlib
14    0000              section bss_string
15    0000              
16    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
17    0000              
135   0000              section bss_lib
136   0000              section bss_compiler
137   0000              section bss_user
138   0000              
139   0000              SECTION BSS_END
140   0000              
141   0000              ;; end memory model ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
142   0000              
143   0000              
144   0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
145   0000              
146   0000              ENDIF
147   0000              
148   0000              ;; end memory model ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
149   0000              
22    0000              
23    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
24    0000              ;; GLOBAL SYMBOLS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
25    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
26    0000              
27    0000              include "../clib_constants.inc"
1     0000              
2     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
3     0000              ;; library constants ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
5     0000              
6     0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
7     0000                 ;; error
8     0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
9     0000              
10    0000                 ; keep consistent with "errno.h"
11    0000              
12    0000                 PUBLIC __EOK, __EACCES, __EBADF
13    0000                 PUBLIC __EBDFD, __EDOM, __EFBIG
14    0000                 PUBLIC __EINVAL, __EMFILE, __ENFILE
15    0000                 PUBLIC __ENOLCK, __ENOMEM, __ENOTSUP
16    0000                 PUBLIC __EOVERFLOW, __ERANGE, __ESTAT
17    0000                 PUBLIC __EWOULDBLOCK, __EAGAIN
18    0000              
19    0000                 defgroup
20    0000                 {
21    0000                    __EOK = 0,
22    0000                    __EACCES,
23    0000                    __EBADF,
24    0000                    __EBDFD,
25    0000                    __EDOM,
26    0000                    __EFBIG,
27    0000                    __EINVAL,
28    0000                    __EMFILE,
29    0000                    __ENFILE,
30    0000                    __ENOLCK,
31    0000                    __ENOMEM,
32    0000                    __ENOTSUP,
33    0000                    __EOVERFLOW,
34    0000                    __ERANGE,
35    0000                    __ESTAT,
36    0000                    __EWOULDBLOCK,
37    0000                    __EAGAIN = __EWOULDBLOCK,
38    0000              
39    0000                    ; define next error number for targets
40    0000              
41    0000                    __ERROR_NEXT__ = 50
42    0000                 }
43    0000              
44    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
45    0000                 ;; stdio
46    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
47    0000              
48    0000                 ; must not be changed consistent with "stdio.h"
49    0000              
50    0000                 PUBLIC STDIO_SEEK_SET, STDIO_SEEK_CUR, STDIO_SEEK_END
51    0000              
52    0000                 defc STDIO_SEEK_SET = 0
53    0000                 defc STDIO_SEEK_CUR = 1
54    0000                 defc STDIO_SEEK_END = 2
55    0000              
56    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
57    0000                 ;; threads
58    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
59    0000              
60    0000                 PUBLIC mtx_plain, mtx_recursive, mtx_timed
61    0000              
62    0000                 defc mtx_plain     = $01
63    0000                 defc mtx_recursive = $02
64    0000                 defc mtx_timed     = $04
65    0000              
66    0000                 PUBLIC thrd_success, thrd_error, thrd_nomem
67    0000                 PUBLIC thrd_busy, thrd_timedout
68    0000              
69    0000                 defc thrd_success  = $0000
70    0000                 defc thrd_error    = $0001
71    0000                 defc thrd_nomem    = $0002
72    0000                 defc thrd_busy     = $0004
73    0000                 defc thrd_timedout = $0008
74    0000              
75    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
76    0000                 ;; messages
77    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
78    0000              
79    0000                 ; relative sequence of these messages is significant
80    0000                 ; but can insert other messages as needed
81    0000              
82    0000                 PUBLIC STDIO_MSG_PUTC, STDIO_MSG_WRIT, STDIO_MSG_GETC
83    0000                 PUBLIC STDIO_MSG_EATC, STDIO_MSG_READ, STDIO_MSG_SEEK
84    0000                 PUBLIC STDIO_MSG_ICTL, STDIO_MSG_FLSH, STDIO_MSG_CLOS
85    0000              
86    0000                 PUBLIC ITERM_MSG_GETC, ITERM_MSG_PUTC, ITERM_MSG_PRINT_CURSOR
87    0000                 PUBLIC ITERM_MSG_ERASE_CURSOR, ITERM_MSG_BS, ITERM_MSG_BS_PWD
88    0000                 PUBLIC ITERM_MSG_READLINE_BEGIN, ITERM_MSG_READLINE_END, ITERM_MSG_BELL
89    0000                 PUBLIC ITERM_MSG_ERASE_CURSOR_PWD, ITERM_MSG_INTERRUPT
90    0000              
91    0000                 PUBLIC OTERM_MSG_PUTC, OTERM_MSG_TTY, OTERM_MSG_PRINTC
92    0000                 PUBLIC OTERM_MSG_SCROLL, OTERM_MSG_CLS, OTERM_MSG_PAUSE
93    0000                 PUBLIC OTERM_MSG_BELL, OTERM_MSG_PSCROLL
94    0000              
95    0000                 defgroup
96    0000                 {
97    0000                    ; stdio messages
98    0000              
99    0000                    STDIO_MSG_PUTC = 1,
100   0000                    STDIO_MSG_WRIT,
101   0000                    STDIO_MSG_GETC,
102   0000                    STDIO_MSG_EATC,
103   0000                    STDIO_MSG_READ,
104   0000                    STDIO_MSG_SEEK,
105   0000                    STDIO_MSG_ICTL,
106   0000                    STDIO_MSG_FLSH,
107   0000                    STDIO_MSG_CLOS,
108   0000              
109   0000                    ; input terminal messages
110   0000              
111   0000                    ITERM_MSG_GETC = 15,
112   0000                    ITERM_MSG_INTERRUPT,
113   0000                    ITERM_MSG_PUTC,
114   0000                    ITERM_MSG_PRINT_CURSOR,
115   0000                    ITERM_MSG_ERASE_CURSOR,
116   0000                    ITERM_MSG_ERASE_CURSOR_PWD,
117   0000                    ITERM_MSG_BS,
118   0000                    ITERM_MSG_BS_PWD,
119   0000                    ITERM_MSG_READLINE_BEGIN,
120   0000                    ITERM_MSG_READLINE_END,
121   0000                    ITERM_MSG_BELL,
122   0000              
123   0000                    __MESSAGE_ITERM_NEXT__,
124   0000              
125   0000                    ; output terminal messages
126   0000              
127   0000                    OTERM_MSG_PUTC = 30,
128   0000                    OTERM_MSG_TTY,
129   0000                    OTERM_MSG_PRINTC,
130   0000                    OTERM_MSG_SCROLL,
131   0000                    OTERM_MSG_CLS,
132   0000                    OTERM_MSG_PAUSE,
133   0000                    OTERM_MSG_BELL,
134   0000                    OTERM_MSG_PSCROLL,
135   0000              
136   0000                    __MESSAGE_OTERM_NEXT__,
137   0000              
138   0000                    ; define next message id for targets
139   0000              
140   0000                    __MESSAGE_NEXT__ = 45
141   0000              
142   0000                 }
143   0000              
144   0000                 ; serial character i/o messages
145   0000              
146   0000                 PUBLIC ICHAR_MSG_GETC
147   0000                 PUBLIC OCHAR_MSG_PUTC_BIN, OCHAR_MSG_PUTC
148   0000              
149   0000                 defc ICHAR_MSG_GETC     = ITERM_MSG_GETC
150   0000                 defc OCHAR_MSG_PUTC_BIN = OTERM_MSG_PUTC
151   0000                 defc OCHAR_MSG_PUTC     = OTERM_MSG_PRINTC
152   0000              
153   0000              
154   0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
155   0000                 ;; ioctls
156   0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
157   0000              
158   0000                 ; bit patterns are significant, consistent with "ioctl.h"
159   0000              
160   0000                 ; all devices, FILE type = $00
161   0000              
162   0000                 PUBLIC IOCTL_RESET
163   0000              
164   0000                 defc IOCTL_RESET = $0000
165   0000              
166   0000                 ; console_01_input_terminal, FILE type = $01
167   0000              
168   0000                 PUBLIC IOCTL_ITERM_ECHO, IOCTL_ITERM_PASS, IOCTL_ITERM_LINE
169   0000                 PUBLIC IOCTL_ITERM_COOK, IOCTL_ITERM_CAPS, IOCTL_ITERM_CRLF
170   0000                 PUBLIC IOCTL_ITERM_CURS
171   0000              
172   0000                 defc IOCTL_ITERM_ECHO = $c081
173   0000                 defc IOCTL_ITERM_PASS = $c041
174   0000                 defc IOCTL_ITERM_LINE = $c021
175   0000                 defc IOCTL_ITERM_COOK = $c011
176   0000                 defc IOCTL_ITERM_CAPS = $c009
177   0000                 defc IOCTL_ITERM_CRLF = $c101
178   0000                 defc IOCTL_ITERM_CURS = $c201
179   0000              
180   0000                 PUBLIC IOCTL_ITERM_TIE, IOCTL_ITERM_GET_EDITBUF, IOCTL_ITERM_SET_EDITBUF
181   0000              
182   0000                 defc IOCTL_ITERM_TIE         = $0201
183   0000                 defc IOCTL_ITERM_GET_EDITBUF = $0381
184   0000                 defc IOCTL_ITERM_SET_EDITBUF = $0301
185   0000              
186   0000                 ; console_01_output_terminal, FILE type = $02
187   0000              
188   0000                 PUBLIC IOCTL_OTERM_PAGE, IOCTL_OTERM_PAUSE, IOCTL_OTERM_COOK
189   0000                 PUBLIC IOCTL_OTERM_CRLF, IOCTL_OTERM_CLEAR, IOCTL_OTERM_SIGNAL
190   0000                 PUBLIC IOCTL_OTERM_BELL
191   0000              
192   0000                 defc IOCTL_OTERM_PAGE   = $c082
193   0000                 defc IOCTL_OTERM_PAUSE  = $c042
194   0000                 defc IOCTL_OTERM_COOK   = $c022
195   0000                 defc IOCTL_OTERM_CRLF   = $c012
196   0000                 defc IOCTL_OTERM_CLEAR  = $e002
197   0000                 defc IOCTL_OTERM_SIGNAL = $c202
198   0000                 defc IOCTL_OTERM_BELL   = $c102
199   0000              
200   0000                 PUBLIC IOCTL_OTERM_CLS, IOCTL_OTERM_RESET_SCROLL
201   0000                 PUBLIC IOCTL_OTERM_GET_WINDOW_COORD, IOCTL_OTERM_SET_WINDOW_COORD
202   0000                 PUBLIC IOCTL_OTERM_GET_WINDOW_RECT, IOCTL_OTERM_SET_WINDOW_RECT
203   0000                 PUBLIC IOCTL_OTERM_GET_CURSOR_COORD, IOCTL_OTERM_SET_CURSOR_COORD
204   0000                 PUBLIC IOCTL_OTERM_GET_OTERM, IOCTL_OTERM_SCROLL, IOCTL_OTERM_FONT
205   0000              
206   0000                 defc IOCTL_OTERM_CLS              = $0102
207   0000                 defc IOCTL_OTERM_RESET_SCROLL     = $0202
208   0000                 defc IOCTL_OTERM_GET_WINDOW_COORD = $0382
209   0000                 defc IOCTL_OTERM_SET_WINDOW_COORD = $0302
210   0000                 defc IOCTL_OTERM_GET_WINDOW_RECT  = $0482
211   0000                 defc IOCTL_OTERM_SET_WINDOW_RECT  = $0402
212   0000                 defc IOCTL_OTERM_GET_CURSOR_COORD = $0582
213   0000                 defc IOCTL_OTERM_SET_CURSOR_COORD = $0502
214   0000                 defc IOCTL_OTERM_GET_OTERM        = $0602
215   0000                 defc IOCTL_OTERM_SCROLL           = $0702
216   0000                 defc IOCTL_OTERM_FONT             = $0802
217   0000              
218   0000                 PUBLIC IOCTL_OTERM_FZX_GET_PAPER_COORD, IOCTL_OTERM_FZX_SET_PAPER_COORD
219   0000                 PUBLIC IOCTL_OTERM_FZX_GET_PAPER_RECT, IOCTL_OTERM_FZX_SET_PAPER_RECT
220   0000                 PUBLIC IOCTL_OTERM_FZX_LEFT_MARGIN, IOCTL_OTERM_FZX_LINE_SPACING
221   0000                 PUBLIC IOCTL_OTERM_FZX_SPACE_EXPAND
222   0000                 PUBLIC IOCTL_OTERM_FZX_GET_FZX_STATE, IOCTL_OTERM_FZX_SET_FZX_STATE
223   0000              
224   0000                 defc IOCTL_OTERM_FZX_GET_PAPER_COORD = $0a82
225   0000                 defc IOCTL_OTERM_FZX_SET_PAPER_COORD = $0a02
226   0000                 defc IOCTL_OTERM_FZX_GET_PAPER_RECT  = $0b82
227   0000                 defc IOCTL_OTERM_FZX_SET_PAPER_RECT  = $0b02
228   0000                 defc IOCTL_OTERM_FZX_LEFT_MARGIN     = $0c02
229   0000                 defc IOCTL_OTERM_FZX_LINE_SPACING    = $0d02
230   0000                 defc IOCTL_OTERM_FZX_SPACE_EXPAND    = $0e02
231   0000                 defc IOCTL_OTERM_FZX_GET_FZX_STATE   = $0f82
232   0000                 defc IOCTL_OTERM_FZX_SET_FZX_STATE   = $0f02
233   0000              
234   0000                 ; character_00_input, FILE type = $03
235   0000              
236   0000                 PUBLIC IOCTL_ICHAR_CRLF
237   0000              
238   0000                 defc IOCTL_ICHAR_CRLF = $c103
239   0000              
240   0000                 ; character_00_output, FILE type = $04
241   0000              
242   0000                 PUBLIC IOCTL_OCHAR_CRLF
243   0000              
244   0000                 defc IOCTL_OCHAR_CRLF = $c014
245   0000              
246   0000              ;; end library constants ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
247   0000              
28    0000              include "clib_target_constants.inc"
1     0000              
2     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
3     0000              ;; target library constants ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
5     0000              
6     0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
7     0000                 ;; target error
8     0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
9     0000              
10    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
11    0000                 ;; target messages
12    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
13    0000              
14    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
15    0000                 ;; target ioctls
16    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
17    0000              
18    0000              ;; end target library constants ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
19    0000              
29    0000              
30    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
31    0000              ;; INSTANTIATE DRIVERS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
32    0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
33    0000              
34    0000              
35    0000              ; When FILEs and FDSTRUCTs are instantiated labels are assigned
36    0000              ; to point at created structures.
37    0000              ;
38    0000              ; The label formats are:
39    0000              ;
40    0000              ; __i_stdio_file_n     = address of static FILE structure #n (0..__I_STDIO_NUM_FILE-1)
41    0000              ; __i_fcntl_fdstruct_n = address of static FDSTRUCT #n (0..__I_FCNTL_NUM_FD-1)
42    0000              ; __i_fcntl_heap_n     = address of allocation #n on heap (0..__I_FCNTL_NUM_HEAP-1)
43    0000              
44    0000              
45    0000              
46    0000              ;; fd=0, stdin
47    0000              
48    0000              
49    0000              
50    0000              
51    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
52    0000                 ; FILE  : _stdin
53    0000                 ;
54    0000                 ; driver: zalt_00_input_sysctrl
55    0000                 ; fd    : 0
56    0000                 ; mode  : read only
57    0000                 ; type  : 003 = character input
58    0000                 ;
59    0000                 ; ioctl_flags   : 0x0100
60    0000                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
61    0000              
62    0000              
63    0000                 SECTION data_clib
64    0000                 SECTION data_stdio
65    0000              
66    0000                 ; FILE *
67    0000              
68    0000                 PUBLIC _stdin
69    0000              
70    0000  04 00          _stdin:  defw __i_stdio_file_0 + 2
71    0002              
72    0002                 ; FILE structure
73    0002              
74    0002                 __i_stdio_file_0:
75    0002              
76    0002                    ; open files link
77    0002              
78    0002  00 00             defw 0
79    0004              
80    0004                    ; jump to underlying fd
81    0004              
82    0004  C3                defb 195			; jp (C3)
83    0005  06 00             defw __i_fcntl_fdstruct_0
84    0007              
85    0007                    ; state_flags_0
86    0007                    ; state_flags_1
87    0007                    ; conversion flags
88    0007                    ; ungetc
89    0007              
90    0007  40                defb 0x40      ; read + stdio manages ungetc + normal file type
91    0008  02                defb 0x02      ; last operation was read
92    0009  00                defb 0
93    000A  00                defb 0
94    000B              
95    000B                    ; mtx_recursive
96    000B              
97    000B  00                defb 0         ; thread owner = none
98    000C  02                defb 0x02      ; mtx_recursive
99    000D  00                defb 0         ; lock count = 0
100   000E  FE                defb 0xfe      ; atomic spinlock
101   000F  00 00             defw 0         ; list of blocked threads
102   0011              
103   0011              
104   0011                 ; fd table entry
105   0011              
106   0011                 SECTION data_fcntl_fdtable_body
107   0000  06 00          defw __i_fcntl_fdstruct_0
108   0002              
109   0002                 ; FDSTRUCT structure
110   0002              
111   0002                 SECTION data_fcntl_stdio_heap_body
112   0000              
113   0000                 EXTERN console_01_input_terminal_fdriver
114   0000                 EXTERN zalt_00_input_sysctrl
115   0000              
116   0000                 __i_fcntl_heap_0:
117   0000              
118   0000                    ; heap header
119   0000              
120   0000  17 00             defw __i_fcntl_heap_1
121   0002  17 00             defw 23
122   0004  00 00             defw 0
123   0006              
124   0006                 __i_fcntl_fdstruct_0:
125   0006              
126   0006                    ; FDSTRUCT structure
127   0006              
128   0006                    ; call to first entry to driver
129   0006              
130   0006  CD                defb 205
131   0007  00 00             defw console_01_input_terminal_fdriver
132   0009              
133   0009                    ; jump to driver
134   0009              
135   0009  C3                defb 195
136   000A  00 00             defw zalt_00_input_sysctrl
137   000C              
138   000C                    ; flags
139   000C                    ; reference_count
140   000C                    ; mode_byte
141   000C              
142   000C  03                defb 0x03      ; stdio handles ungetc + type = character input
143   000D  02                defb 2
144   000E  01                defb 0x01      ; read only
145   000F              
146   000F                    ; ioctl_flags
147   000F              
148   000F  00 01             defw 0x0100
149   0011              
150   0011                    ; mtx_plain
151   0011              
152   0011  00                defb 0         ; thread owner = none
153   0012  01                defb 0x01      ; mtx_plain
154   0013  00                defb 0         ; lock count = 0
155   0014  FE                defb 0xfe      ; atomic spinlock
156   0015  00 00             defw 0         ; list of blocked threads
157   0017              
158   0017              
159   0017                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
160   0017              
161   0017              
162   0017              ;; fd=1, stdout
163   0017              
164   0017              
165   0017              
166   0017              
167   0017                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
168   0017                 ; FILE  : _stdout
169   0017                 ;
170   0017                 ; driver: zalt_00_output_sysctrl
171   0017                 ; fd    : 1
172   0017                 ; mode  : write only
173   0017                 ; type  : 004 = character output
174   0017                 ;
175   0017                 ; ioctl_flags   : 0x0010
176   0017                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
177   0017              
178   0017              
179   0017                 SECTION data_clib
180   0000                 SECTION data_stdio
181   0011              
182   0011                 ; FILE *
183   0011              
184   0011                 PUBLIC _stdout
185   0011              
186   0011  15 00          _stdout:  defw __i_stdio_file_1 + 2
187   0013              
188   0013                 ; FILE structure
189   0013              
190   0013                 __i_stdio_file_1:
191   0013              
192   0013                    ; open files link
193   0013              
194   0013  02 00             defw __i_stdio_file_0
195   0015              
196   0015                    ; jump to underlying fd
197   0015              
198   0015  C3                defb 195			; jp (C3)
199   0016  1D 00             defw __i_fcntl_fdstruct_1
200   0018              
201   0018                    ; state_flags_0
202   0018                    ; state_flags_1
203   0018                    ; conversion flags
204   0018                    ; ungetc
205   0018              
206   0018  80                defb 0x80         ; write + normal file type
207   0019  00                defb 0            ; last operation was write
208   001A  00                defb 0
209   001B  00                defb 0
210   001C              
211   001C                    ; mtx_recursive
212   001C              
213   001C  00                defb 0         ; thread owner = none
214   001D  02                defb 0x02      ; mtx_recursive
215   001E  00                defb 0         ; lock count = 0
216   001F  FE                defb 0xfe      ; atomic spinlock
217   0020  00 00             defw 0         ; list of blocked threads
218   0022              
219   0022              
220   0022                 ; fd table entry
221   0022              
222   0022                 SECTION data_fcntl_fdtable_body
223   0002  1D 00          defw __i_fcntl_fdstruct_1
224   0004              
225   0004                 ; FDSTRUCT structure
226   0004              
227   0004                 SECTION data_fcntl_stdio_heap_body
228   0017              
229   0017                 EXTERN console_01_output_terminal_fdriver
230   0017                 EXTERN zalt_00_output_sysctrl
231   0017              
232   0017                 __i_fcntl_heap_1:
233   0017              
234   0017                    ; heap header
235   0017              
236   0017  2E 00             defw __i_fcntl_heap_2
237   0019  17 00             defw 23
238   001B  00 00             defw __i_fcntl_heap_0
239   001D              
240   001D                 __i_fcntl_fdstruct_1:
241   001D              
242   001D                    ; FDSTRUCT structure
243   001D              
244   001D                    ; call to first entry to driver
245   001D              
246   001D  CD                defb 205
247   001E  00 00             defw console_01_output_terminal_fdriver
248   0020              
249   0020                    ; jump to driver
250   0020              
251   0020  C3                defb 195
252   0021  00 00             defw zalt_00_output_sysctrl
253   0023              
254   0023                    ; flags
255   0023                    ; reference_count
256   0023                    ; mode_byte
257   0023              
258   0023  04                defb 0x04      ; type = character output
259   0024  02                defb 2
260   0025  02                defb 0x02      ; write only
261   0026              
262   0026                    ; ioctl_flags
263   0026              
264   0026  10 00             defw 0x0010
265   0028              
266   0028                    ; mtx_plain
267   0028              
268   0028  00                defb 0         ; thread owner = none
269   0029  01                defb 0x01      ; mtx_plain
270   002A  00                defb 0         ; lock count = 0
271   002B  FE                defb 0xfe      ; atomic spinlock
272   002C  00 00             defw 0         ; list of blocked threads
273   002E              
274   002E              
275   002E                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
276   002E              
277   002E              
278   002E              ;; fd=2, stderr
279   002E              
280   002E              
281   002E              
282   002E                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
283   002E                 ; DUPED FILE DESCRIPTOR
284   002E                 ;
285   002E                 ; FILE  : _stderr
286   002E                 ; flags : 0x80
287   002E                 ;
288   002E                 ; fd    : 2
289   002E                 ; dup fd: __i_fcntl_fdstruct_1
290   002E                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
291   002E              
292   002E              
293   002E                 SECTION data_clib
294   0000                 SECTION data_stdio
295   0022              
296   0022                 ; FILE *
297   0022              
298   0022                 PUBLIC _stderr
299   0022              
300   0022  26 00          _stderr:  defw __i_stdio_file_2 + 2
301   0024              
302   0024                 ; FILE structure
303   0024              
304   0024                 __i_stdio_file_2:
305   0024              
306   0024                    ; open files link
307   0024              
308   0024  13 00             defw __i_stdio_file_1
309   0026              
310   0026                    ; jump to duped fd
311   0026              
312   0026  C3                defb 195
313   0027  1D 00             defw __i_fcntl_fdstruct_1
314   0029              
315   0029                    ; state_flags_0
316   0029                    ; state_flags_1
317   0029                    ; conversion flags
318   0029                    ; ungetc
319   0029              
320   0029  80                defb 0x80
321   002A  00                defb 0
322   002B  00                defb 0
323   002C  00                defb 0
324   002D              
325   002D                    ; mtx_recursive
326   002D              
327   002D  00                defb 0         ; thread owner = none
328   002E  02                defb 0x02      ; mtx_recursive
329   002F  00                defb 0         ; lock count = 0
330   0030  FE                defb 0xfe      ; atomic spinlock
331   0031  00 00             defw 0         ; list of blocked threads
332   0033              
333   0033              
334   0033                 ; fd table entry
335   0033              
336   0033                 SECTION data_fcntl_fdtable_body
337   0004  1D 00          defw __i_fcntl_fdstruct_1
338   0006              
339   0006                 ; FDSTRUCT structure
340   0006              
341   0006                 defc __i_fcntl_fdstruct_2 = __i_fcntl_fdstruct_1
342   0006              
343   0006                 ; adjust reference count on duped FDSTRUCT
344   0006              
345   0006                 SECTION code_crt_init
346   0000              
347   0000  21 24 00       ld hl,__i_fcntl_fdstruct_1 + 7     ; & FDSTRUCT.ref_count
348   0003  34             inc (hl)
349   0004  34             inc (hl)
350   0005              
351   0005              
352   0005                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
353   0005              
354   0005              
355   0005              
356   0005                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
357   0005                 ;; create open and closed FILE lists
358   0005                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
359   0005              
360   0005                 ; __clib_fopen_max   = max number of open FILEs specified by user
361   0005                 ; 3 = number of static FILEs instantiated in crt
362   0005                 ; __i_stdio_file_n   = address of static FILE structure #n (0..I_STDIO_FILE_NUM-1)
363   0005              
364   0005                 SECTION data_clib
365   0000                 SECTION data_stdio
366   0033              
367   0033                 IF (__clib_fopen_max > 0) || (3 > 0)
368   0033              
369   0033                    ; number of FILEs > 0
370   0033              
371   0033                    ; construct list of open files
372   0033              
373   0033                    IF 3 > 0
374   0033              
375   0033                       ; number of FILEs statically generated > 0
376   0033              
377   0033                       SECTION data_clib
378   0000                       SECTION data_stdio
379   0033              
380   0033                       PUBLIC __stdio_open_file_list
381   0033              
382   0033  24 00                __stdio_open_file_list:  defw __i_stdio_file_2
383   0035              
384   0035                    ELSE
385   0035              
386   0035                       ; number of FILEs statically generated = 0
387   0035              
388   0035                       SECTION bss_clib
389   0035                       SECTION bss_stdio
390   0035              
391   0035                       PUBLIC __stdio_open_file_list
392   0035              
393   0035                       __stdio_open_file_list:  defw 0
394   0035              
395   0035                    ENDIF
396   0035              
397   0035                    ; construct list of closed / available FILEs
398   0035              
399   0035                    SECTION data_clib
400   0000                    SECTION data_stdio
401   0035              
402   0035                    PUBLIC __stdio_closed_file_list
403   0035              
404   0035  00 00 35 00       __stdio_closed_file_list:   defw 0, __stdio_closed_file_list
405   0039              
406   0039                    IF __clib_fopen_max > 3
407   0039              
408   0039                       ; create extra FILE structures
409   0039              
410   0039                       SECTION bss_clib
411   0039                       SECTION bss_stdio
412   0039              
413   0039                       __stdio_file_extra:      defs (__clib_fopen_max - 3) * 15
414   0039              
415   0039                       SECTION code_crt_init
416   0039              
417   0039                          ld bc,__stdio_closed_file_list
418   0039                          ld de,__stdio_file_extra
419   0039                          ld l,__clib_fopen_max - 3
420   0039              
421   0039                       loop:
422   0039              
423   0039                          push hl
424   0039              
425   0039                          EXTERN asm_p_forward_list_alt_push_front
426   0039                          call asm_p_forward_list_alt_push_front
427   0039              
428   0039                          ld de,15
429   0039                          add hl,de
430   0039                          ex de,hl
431   0039              
432   0039                          pop hl
433   0039              
434   0039                          dec l
435   0039                          jr nz, loop
436   0039              
437   0039                    ENDIF
438   0039              
439   0039                 ENDIF
440   0039              
441   0039                 IF (__clib_fopen_max = 0) && (3 = 0)
442   0039              
443   0039                    ; create empty file lists
444   0039              
445   0039                    SECTION bss_clib
446   0039                    SECTION bss_stdio
447   0039              
448   0039                    PUBLIC __stdio_open_file_list
449   0039                    __stdio_open_file_list:  defw 0
450   0039              
451   0039                    SECTION data_clib
452   0039                    SECTION data_stdio
453   0039              
454   0039                    PUBLIC __stdio_closed_file_list
455   0039                    __stdio_closed_file_list:   defw 0, __stdio_closed_file_list
456   0039              
457   0039                 ENDIF
458   0039              
459   0039                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
460   0039                 ;; create fd table
461   0039                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
462   0039              
463   0039                 ; __clib_open_max  = max number of open fds specified by user
464   0039                 ; 3 = number of static file descriptors created
465   0039              
466   0039                 PUBLIC __fcntl_fdtbl
467   0039                 PUBLIC __fcntl_fdtbl_size
468   0039              
469   0039                 IF 3 > 0
470   0039              
471   0039                    ; create rest of fd table in data segment
472   0039              
473   0039                    SECTION data_fcntl_fdtable_body
474   0006              
475   0006                    EXTERN __data_fcntl_fdtable_body_head
476   0006              
477   0006                    defc __fcntl_fdtbl = __data_fcntl_fdtable_body_head
478   0006              
479   0006                    IF __clib_open_max > 3
480   0006              
481   0006                       SECTION data_fcntl_fdtable_body
482   0006              
483   0006                       defs (__clib_open_max - 3) * 2
484   0006                       defc __fcntl_fdtbl_size = __clib_open_max
485   0006              
486   0006                    ELSE
487   0006              
488   0006                       defc __fcntl_fdtbl_size = 3
489   0006              
490   0006                    ENDIF
491   0006              
492   0006                 ELSE
493   0006              
494   0006                    IF __clib_open_max > 0
495   0006              
496   0006                       ; create fd table in bss segment
497   0006              
498   0006                       SECTION bss_clib
499   0006                       SECTION bss_fcntl
500   0006              
501   0006                       __fcntl_fdtbl:        defs __clib_open_max * 2
502   0006              
503   0006                    ELSE
504   0006              
505   0006                       ; no fd table at all
506   0006              
507   0006                       defc __fcntl_fdtbl = 0
508   0006              
509   0006                    ENDIF
510   0006              
511   0006                    defc __fcntl_fdtbl_size = __clib_open_max
512   0006              
513   0006                 ENDIF
514   0006              
515   0006                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
516   0006                 ;; finalize stdio heap
517   0006                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
518   0006              
519   0006                 ; __clib_stdio_heap_size  = desired stdio heap size in bytes
520   0006                 ; 46  = byte size of static FDSTRUCTs
521   0006                 ; 2   = number of heap allocations
522   0006                 ; __i_fcntl_heap_n     = address of allocation #n on heap (0..__I_FCNTL_NUM_HEAP-1)
523   0006              
524   0006                 IF 46 > 0
525   0006              
526   0006                    ; static FDSTRUCTs have been allocated in the heap
527   0006              
528   0006                    SECTION data_clib
529   0000                    SECTION data_fcntl
530   0000              
531   0000                    PUBLIC __stdio_heap
532   0000              
533   0000  00 00             __stdio_heap:            defw __stdio_block
534   0002              
535   0002                    SECTION data_fcntl_stdio_heap_head
536   0000              
537   0000                    __stdio_block:
538   0000              
539   0000  00                   defb 0                ; no owner
540   0001  01                   defb 0x01             ; mtx_plain
541   0002  00                   defb 0                ; number of lock acquisitions
542   0003  FE                   defb 0xfe             ; spinlock (unlocked)
543   0004  00 00                defw 0                ; list of threads blocked on mutex
544   0006              
545   0006                    IF __clib_stdio_heap_size > (46 + 14)
546   0006              
547   0006                       ; expand stdio heap to desired size
548   0006              
549   0006                       SECTION data_fcntl_stdio_heap_body
550   002E              
551   002E                       __i_fcntl_heap_2:
552   002E              
553   002E  00 00                   defw __i_fcntl_heap_3
554   0030  00 00                   defw 0
555   0032  17 00                   defw __i_fcntl_heap_1
556   0034  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      0054  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      0074  00 00 00 00 
                                    defs __clib_stdio_heap_size - 46 - 14
557   0078              
558   0078                       ; terminate stdio heap
559   0078              
560   0078                       SECTION data_fcntl_stdio_heap_tail
561   0000              
562   0000  00 00                __i_fcntl_heap_3:   defw 0
563   0002              
564   0002                    ELSE
565   0002              
566   0002                       ; terminate stdio heap
567   0002              
568   0002                       SECTION data_fcntl_stdio_heap_tail
569   0002              
570   0002                       __i_fcntl_heap_2:   defw 0
571   0002              
572   0002                    ENDIF
573   0002              
574   0002                 ELSE
575   0002              
576   0002                    ; no FDSTRUCTs statically created
577   0002              
578   0002                    IF __clib_stdio_heap_size > 14
579   0002              
580   0002                       SECTION data_clib
581   0002                       SECTION data_fcntl
582   0002              
583   0002                       PUBLIC __stdio_heap
584   0002              
585   0002                       __stdio_heap:         defw __stdio_block
586   0002              
587   0002                       SECTION bss_clib
588   0002                       SECTION bss_fcntl
589   0002              
590   0002                       PUBLIC __stdio_block
591   0002              
592   0002                       __stdio_block:         defs __clib_stdio_heap_size
593   0002              
594   0002                       SECTION code_crt_init
595   0002              
596   0002                       ld hl,__stdio_block
597   0002                       ld bc,__clib_stdio_heap_size
598   0002              
599   0002                       EXTERN asm_heap_init
600   0002                       call asm_heap_init
601   0002              
602   0002                    ENDIF
603   0002              
604   0002                 ENDIF
605   0002              
606   0002              
607   0002              
608   0002              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
609   0002              ;; STARTUP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
610   0002              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
611   0002              
612   0002              SECTION CODE
613   0000              
614   0000              ; exports
615   0000              public __Start, __Exit
616   0000              
617   0000              ; imports
618   0000              extern _main
619   0000              
620   0000              ;**************************************************************
621   0000              IF __crt_org_code = 0
622   0000              ;**************************************************************
623   0000              
624   0000                 ; address = 0x0000
625   0000                 ; page0 and isr_vectortable have a fixed org
626   0000                 include "startup/page0.asm"
1     0000              ;
2     0000              ; This file defines the memory layout for page zero.
3     0000              ;
4     0000              
5     0000              ; exports
6     0000              public bios_load_byte_instruction
7     0000              public bios_load_word_instruction
8     0000              ; export bios vars
9     0000              public bios_var_ram_top_page
10    0000              public bios_var_ram_page
11    0000              public bios_var_ram_active_page
12    0000              
13    0000              ; imports
14    0000              extern bios_reset_init
15    0000              extern bios_trap_illegal
16    0000              
17    0000              module page0
18    0000              
19    0000              ; Declares fixed addresses and startup routines
20    0000              
21    0000              ;
22    0000              ; Page-0 memory layout
23    0000              ;
24    0000              
25    0000              	;defs 0x0000 - ASMPC
26    0000              ; address = 0x0000
27    0000              ; !RESET and RST00
28    0000  F3          	di						; from warm boot (rst00), interrupts may be enabled
29    0001  C3 03 02    	jp	bios_reset_init
30    0004              
31    0004  00 00 00 00 	defs 0x0008 - ASMPC
32    0008              	; address = 0x0008
33    0008              	; RTS08
34    0008              	;	di					; if you need interrupts disabled, do that here
35    0008  C3 78 00    	jp	BiosFn1
36    000B              
37    000B              
38    000B  00 00 00 00 00 
                        	defs 0x0010 - ASMPC
39    0010              	; address = 0x0010
40    0010              	; RST10
41    0010              	;	di					; if you need interrupts disabled, do that here
42    0010  C3 78 00    	jp	BiosFn2
43    0013              
44    0013  00 00 00 00 00 
                        	defs 0x0018 - ASMPC
45    0018              	; address = 0x0018
46    0018              	; RST18
47    0018              	;	di					; if you need interrupts disabled, do that here
48    0018  C3 78 00    	jp	BiosFn3
49    001B              
50    001B              
51    001B  00 00 00 00 00 
                        	defs 0x0020 - ASMPC
52    0020              	; address = 0x0020
53    0020              	; RST20
54    0020              	;	di					; if you need interrupts disabled, do that here
55    0020  C3 78 00    	jp	BiosFn4
56    0023              
57    0023              
58    0023  00 00 00 00 00 
                        	defs 0x0028 - ASMPC
59    0028              	; address = 0x0028
60    0028              	; RST28
61    0028              	;	di					; if you need interrupts disabled, do that here
62    0028  C3 78 00    	jp	BiosFn5
63    002B              
64    002B              
65    002B  00 00 00 00 00 
                        	defs 0x0030 - ASMPC
66    0030              	; address = 0x0030
67    0030              	; RST30
68    0030              	;	di					; if you need interrupts disabled, do that here
69    0030  C3 78 00    	jp	BiosFn6
70    0033              
71    0033              
72    0033  00 00 00 00 00 
                        	defs 0x0038 - ASMPC
73    0038              	; address = 0x0038
74    0038              	; RST38 and IM1
75    0038              	; used to trap illegal jumps and interrupt mode
76    0038  F3          	di							; disable interrupts
77    0039              ifdef DEBUG
78    0039              	call debug_save_registers	; save cpu state
79    0039              endif
80    0039  C3 02 02    	jp	bios_trap_illegal		; call the handler for illegal calls.
81    003C              
82    003C              
83    003C              ; bios vars
84    003C  00 00 00 00 	defs 0x0040 - ASMPC
85    0040              bios_var_ram_top_page:
86    0040  00          	defb $00		; last valid ram page
87    0041              bios_var_ram_top:
88    0041  00 00       	defw $0000		; last valid ram address on last page
89    0043              bios_var_ram_active_page:
90    0043  00          	defb $00		; current active ram page
91    0044              
92    0044              
93    0044  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      0064  00 00 
                        	defs 0x0066 - ASMPC
94    0066              	; address = 0x0066
95    0066              	; !NMI
96    0066              ifdef DEBUG
97    0066              	call debug_save_registers	; save cpu state
98    0066              	call debug_info_point		; communicate InfoPoint to SystemController
99    0066              endif
100   0066  ED 45       	retn
101   0068              
102   0068              
103   0068              
104   0068              ; When a program calls an RST function its PC is stored on the SP.
105   0068              ; The RST function can define an additional byte (or two) immediate after the RST instruction.
106   0068              ; This extra information would have meaning for the RST operation.
107   0068              
108   0068              ; This method reads the single byte that follows the RST instruction
109   0068              ; and adjusts the returns address to return control after that byte.
110   0068              ; rst{n} defb $xx
111   0068              ; pre-condition:
112   0068              ;	The SP contains a direct return address used to return from this method
113   0068              ;	and it contains the return address from where the RST method was called -
114   0068              ;	that will be adjusted.
115   0068              ; post-condition:
116   0068              ;	Register a will contain the extra RST byte and the RST return address is adjusted.
117   0068              bios_load_byte_instruction:
118   0068  D1          	pop de		; this is the immediate return address and must be preserved.
119   0069  E1          	pop	hl		; this is the RST return address and must be adjusted
120   006A  7E          	ld a, (hl)	; get the extra byte
121   006B  23          	inc hl		; set RST return address past the data byte
122   006C  E5          	push hl		; put RST return address back on stack
123   006D  D5          	push de		; as well as the immediate return address
124   006E  C9          	ret
125   006F              
126   006F              ; This method reads two bytes (a word) that follows the RST instruction
127   006F              ; and adjusts the returns address to return control after that word.
128   006F              ; rst{n} defw $xxxx
129   006F              ; pre-condition:
130   006F              ;	The SP contains a direct return address used to return from this method
131   006F              ;	and it contains the return address from where the RST method was called -
132   006F              ;	that will be adjusted.
133   006F              ;	The word bytes are little endian: so the first is LSB and the next is MSB.
134   006F              ; post-condition:
135   006F              ;	Register bc will contain the extra RST bytes and the RST return address is adjusted.
136   006F              ;	Register c contains the first (lsb) and b contains the second (msb) byte after the RST instruction.
137   006F              bios_load_word_instruction:
138   006F  D1          	pop de		; this is the immediate return address and must be preserved.
139   0070  E1          	pop	hl		; this is the RST return address and must be adjusted
140   0071  4E          	ld c, (hl)	; get the first extra byte
141   0072  23          	inc hl		; prepare to get the next data byte
142   0073  46          	ld b, (hl)	; get the next extra byte
143   0074  23          	inc hl		; set RST return address past the data word
144   0075  E5          	push hl		; put RST return address back on stack
145   0076  D5          	push de		; as well as the immediate return address
146   0077  C9          	ret
147   0078              
148   0078              BiosFn1:
149   0078              ; bios function #1
150   0078              
151   0078              BiosFn2:
152   0078              ; bios function #2
153   0078              
154   0078              BiosFn3:
155   0078              ; bios function #3
156   0078              
157   0078              BiosFn4:
158   0078              ; bios function #4
159   0078              
160   0078              BiosFn5:
161   0078              ; bios function #5
162   0078              
163   0078              BiosFn6:
164   0078              ; bios function #6
165   0078  76          	halt
166   0079              
167   0079              
168   0079              ;
169   0079              ; ISR Table (IM2) of 16-bit jump addresses (I=1) 256 bytes max
170   0079              ;
171   0079              
172   0079              ; ISR Table is located at page 1 ($0100, I=1).
173   0079              defc isr_table_address 	= $0100		; hi-byte is same as the isr_table_index
174   0079              defc isr_table_index 	= 1         ; used to initialie I register
175   0079              defc isr_table_address_end = isr_table_address + $0100	; 256 byte of isr table
176   0079              
177   0079  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      0099  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      00B9  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      00D9  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      00F9  00 00 00 00 00 00 00 
                        defs isr_table_address - ASMPC
178   0100              
179   0100              ; The lo address byte (A1-A7: A0=0) is put on the databus by the interrupting device.
180   0100              ; The hi address byte (A8-A15) is supplied by the I register that is initialized to (page) 1.
181   0100  00 02       defw	isr_null_vector		; Address of ISR #0
182   0102  00 02       defw	isr_null_vector		; Address of ISR #1
183   0104  00 02       defw	isr_null_vector		; Address of ISR #2
184   0106  00 02       defw	isr_null_vector		; Address of ISR #3
185   0108  00 02       defw	isr_null_vector		; Address of ISR #4
186   010A  00 02       defw	isr_null_vector		; Address of ISR #5
187   010C  00 02       defw	isr_null_vector		; Address of ISR #6
188   010E  00 02       defw	isr_null_vector		; Address of ISR #7
189   0110  00 02       defw	isr_null_vector		; Address of ISR #8
190   0112  00 02       defw	isr_null_vector		; Address of ISR #9
191   0114  00 02       defw	isr_null_vector		; Address of ISR #10
192   0116  00 02       defw	isr_null_vector		; Address of ISR #11
193   0118  00 02       defw	isr_null_vector		; Address of ISR #12
194   011A  00 02       defw	isr_null_vector		; Address of ISR #13
195   011C  00 02       defw	isr_null_vector		; Address of ISR #14
196   011E  00 02       defw	isr_null_vector		; Address of ISR #15
197   0120  00 02       defw	isr_null_vector		; Address of ISR #16
198   0122  00 02       defw	isr_null_vector		; Address of ISR #17
199   0124  00 02       defw	isr_null_vector		; Address of ISR #18
200   0126  00 02       defw	isr_null_vector		; Address of ISR #19
201   0128  00 02       defw	isr_null_vector		; Address of ISR #20
202   012A  00 02       defw	isr_null_vector		; Address of ISR #21
203   012C  00 02       defw	isr_null_vector		; Address of ISR #22
204   012E  00 02       defw	isr_null_vector		; Address of ISR #23
205   0130  00 02       defw	isr_null_vector		; Address of ISR #24
206   0132  00 02       defw	isr_null_vector		; Address of ISR #25
207   0134  00 02       defw	isr_null_vector		; Address of ISR #26
208   0136  00 02       defw	isr_null_vector		; Address of ISR #27
209   0138  00 02       defw	isr_null_vector		; Address of ISR #28
210   013A  00 02       defw	isr_null_vector		; Address of ISR #29
211   013C  00 02       defw	isr_null_vector		; Address of ISR #30
212   013E  00 02       defw	isr_null_vector		; Address of ISR #31
213   0140  00 02       defw	isr_null_vector		; Address of ISR #32
214   0142  00 02       defw	isr_null_vector		; Address of ISR #33
215   0144  00 02       defw	isr_null_vector		; Address of ISR #34
216   0146  00 02       defw	isr_null_vector		; Address of ISR #35
217   0148  00 02       defw	isr_null_vector		; Address of ISR #36
218   014A  00 02       defw	isr_null_vector		; Address of ISR #37
219   014C  00 02       defw	isr_null_vector		; Address of ISR #38
220   014E  00 02       defw	isr_null_vector		; Address of ISR #39
221   0150  00 02       defw	isr_null_vector		; Address of ISR #40
222   0152  00 02       defw	isr_null_vector		; Address of ISR #41
223   0154  00 02       defw	isr_null_vector		; Address of ISR #42
224   0156  00 02       defw	isr_null_vector		; Address of ISR #43
225   0158  00 02       defw	isr_null_vector		; Address of ISR #44
226   015A  00 02       defw	isr_null_vector		; Address of ISR #45
227   015C  00 02       defw	isr_null_vector		; Address of ISR #46
228   015E  00 02       defw	isr_null_vector		; Address of ISR #47
229   0160  00 02       defw	isr_null_vector		; Address of ISR #48
230   0162  00 02       defw	isr_null_vector		; Address of ISR #49
231   0164  00 02       defw	isr_null_vector		; Address of ISR #50
232   0166  00 02       defw	isr_null_vector		; Address of ISR #51
233   0168  00 02       defw	isr_null_vector		; Address of ISR #52
234   016A  00 02       defw	isr_null_vector		; Address of ISR #53
235   016C  00 02       defw	isr_null_vector		; Address of ISR #54
236   016E  00 02       defw	isr_null_vector		; Address of ISR #55
237   0170  00 02       defw	isr_null_vector		; Address of ISR #56
238   0172  00 02       defw	isr_null_vector		; Address of ISR #57
239   0174  00 02       defw	isr_null_vector		; Address of ISR #58
240   0176  00 02       defw	isr_null_vector		; Address of ISR #59
241   0178  00 02       defw	isr_null_vector		; Address of ISR #60
242   017A  00 02       defw	isr_null_vector		; Address of ISR #61
243   017C  00 02       defw	isr_null_vector		; Address of ISR #62
244   017E  00 02       defw	isr_null_vector		; Address of ISR #63
245   0180              
246   0180              ; reserve room for complete table
247   0180  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      01A0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      01C0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      01E0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
                        defs isr_table_address_end - ASMPC
248   0200              
249   0200              ; for full table this would be the last ISR vector
250   0200              ;defw	isr_null_vector		; Address of ISR #127
251   0200              
252   0200              
627   0200                 include "startup/bios.asm"
1     0200              ;
2     0200              ; bios.asm
3     0200              ;
4     0200              
5     0200              ; exports
6     0200              public bios_reset_init
7     0200              public isr_null_vector
8     0200              public bios_trap_illegal
9     0200              
10    0200              ; imports
11    0200              
12    0200              
13    0200              ;
14    0200              ; Start of bios
15    0200              ;
16    0200              
17    0200              ; a dummy isr for initializing the isr vector table
18    0200              isr_null_vector:
19    0200              ifdef DEBUG
20    0200              	halt			; break if debug build
21    0200              endif
22    0200  ED 4D       	reti;			; do nothing, return from interrupt
23    0202              
24    0202              ;	hl contains the source address of illegal call
25    0202              bios_trap_illegal:
26    0202              ifdef DEBUG
27    0202              	halt			; break if debug build
28    0202              endif
29    0202  C7          	rst $00			; reset
30    0203              
31    0203              ; Interrupts are disabled.
32    0203              bios_reset_init:
33    0203  AF          	xor a
34    0204  47          	ld b, a
35    0205  4F          	ld c, a
36    0206  57          	ld d, a
37    0207  5F          	ld e, a
38    0208  67          	ld h, a
39    0209  6F          	ld l, a
40    020A  DD 21 00 00 	ld ix, $0000
41    020E  FD 21 00 00 	ld iy, $0000
42    0212              
43    0212  ED 57       	ld	a, i			; cold boot/hard reset would init I to $00
44    0214  FE 00       	cp	a, $00			; is I zero?
45    0216  20 10       	jr  nz, resetWarm	; nope - warm boot
46    0218              
47    0218              	; initialze ram
48    0218  21 FF FF    	ld hl, $FFFF						; hard-coded ram top (64k)
49    021B  AF          	xor a								; memory page $00
50    021C  22 41 00    	ld (bios_var_ram_top), hl			; init bios vars
51    021F  32 43 00    	ld (bios_var_ram_active_page), a	; init to first page
52    0222              
53    0222              	; !! TEMP !!
54    0222              	;ld hl, bios_memory_page_size	; start of program memory (first page is reserved)
55    0222              	;call bios_memory_init			; call routine to clear/fill program memory
56    0222              
57    0222              	; initialize Interrupt mode
58    0222  3E 01       	ld	a, isr_table_index      ; load I with page address for isr_vector_table
59    0224  ED 47       	ld	i, a			        ; for the ISR jump table (at $0100)
60    0226  ED 5E       	im	2				        ; for IM2
61    0228              
62    0228              ; bios_reset_init jumps here if it detects a warm reset
63    0228              .resetWarm
64    0228              	; TODO reset all registers (except I and R)
65    0228  2A 41 00    	ld hl, (bios_var_ram_top)	; load ram-top
66    022B  F9          	ld sp, hl					; Stack Pointer at Ram Top
67    022C              
68    022C  FB          	ei					; turn on interrupts
69    022D  C3 30 02    	jp __Start			; jmp to C main entry point
70    0230              
71    0230              
72    0230              
73    0230              
74    0230              
75    0230              
76    0230              
628   0230              
629   0230              
630   0230              ;**************************************************************
631   0230              ENDIF
632   0230              ;**************************************************************
633   0230              
634   0230              __Start:
635   0230                 ; parse command line
636   0230                 ; (optional)
637   0230              
638   0230                 ; initialize data section
639   0230                 include "../clib_init_data.inc"
1     0230              
2     0230                 ; initialize data section
3     0230                 ; data section is always at least one byte
4     0230              
5     0230                 IF (__crt_model = 1)
6     0230              
7     0230                    ; rom model + data section is not compressed
8     0230              
9     0230                    EXTERN __CODE_END_head
10    0230                    EXTERN __DATA_head, __DATA_END_tail
11    0230              
12    0230                    ld hl,__CODE_END_head
13    0230                    ld de,__DATA_head
14    0230                    ld bc,__DATA_END_tail - __DATA_head
15    0230              
16    0230                    ldir
17    0230              
18    0230                 ENDIF
19    0230              
20    0230                 IF (__crt_model >= 2)
21    0230              
22    0230                    ; rom model + data section is compressed
23    0230              
24    0230                    EXTERN __CODE_END_head, __DATA_head
25    0230              
26    0230                    ld hl,__CODE_END_head
27    0230                    ld de,__DATA_head
28    0230              
29    0230                    EXTERN asm_dzx7_standard
30    0230                    call asm_dzx7_standard
31    0230              
32    0230                 ENDIF
33    0230              
640   0230              
641   0230                 ; initialize bss section
642   0230                 include "../clib_init_bss.inc"
1     0230              
2     0230                 ; initialize bss section
3     0230              
4     0230                 IF (__crt_model | __crt_initialize_bss)
5     0230              
6     0230                       EXTERN asm_memset
7     0230                       EXTERN __BSS_UNINITIALIZED_tail, __BSS_END_tail
8     0230              
9     0230                       ld hl,__BSS_UNINITIALIZED_tail
10    0230                       ld bc,__BSS_END_tail - __BSS_UNINITIALIZED_tail
11    0230              
12    0230                       ld e,0
13    0230                       call asm_memset
14    0230              
15    0230                 ENDIF
16    0230              
643   0230              
644   0230              SECTION code_crt_init          ; user and library initialization
645   0005              SECTION code_crt_main
646   0000              
647   0000                 ; call user program
648   0000  CD 00 00        call _main                  ; hl = return status
649   0003              
650   0003                 ; run registered exit() functions
651   0003                 IF __clib_exit_stack_size > 0
652   0003                    EXTERN asm_exit
653   0003  C3 00 00          jp asm_exit              ; exit function jumps to __Exit
654   0006                 ENDIF
655   0006              
656   0006              __Exit:
657   0006                 ; abort(), exit(), quickexit() can be called from anywhere
658   0006                 ; so the stack may be unbalanced here
659   0006  E5             push hl                     ; hl = return status
660   0007              
661   0007              SECTION code_crt_exit          ; user and library cleanup
662   0000              SECTION code_crt_return
663   0000              
664   0000                 ; close files
665   0000                 include "../clib_close.inc"
1     0000                 IF __crt_enable_close
2     0000              
3     0000                    ; close open files
4     0000              
5     0000                    ; TODO
6     0000              
7     0000                 ENDIF
8     0000              
666   0000              
667   0000  E1             pop hl                      ; hl = return status
668   0001              
669   0001                 ; exit program
670   0001              zalt_oblivian:
671   0001              IF DEBUG
672   0001                  halt
673   0001              ENDIF
674   0001  18 FE       	jr zalt_oblivian
675   0003              
676   0003              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
677   0003              ;; RUNTIME VARS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
678   0003              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
679   0003              
680   0003              SECTION BSS_UNINITIALIZED
681   0000              
682   0000              ; place any uninitialized data here (eg saved stack pointer)
683   0000              ; bss and data section initialization will not touch it
684   0000              
685   0000              include "../clib_variables.inc"
1     0000              
2     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
3     0000              ;; library variables ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4     0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
5     0000              
6     0000              IF __clib_balloc_table_size > 0
7     0000              
8     0000                 ; create balloc table
9     0000              
10    0000                 SECTION data_clib
11    0000                 SECTION data_alloc_balloc
12    0000              
13    0000                 PUBLIC __balloc_array
14    0000              
15    0000                 __balloc_array:             defw __balloc_table
16    0000              
17    0000                 SECTION bss_clib
18    0000                 SECTION bss_alloc_balloc
19    0000              
20    0000                 __balloc_table:             defs __clib_balloc_table_size * 2
21    0000              
22    0000              ENDIF
23    0000              
24    0000              IF __clib_malloc_heap_size = -1
25    0000              
26    0000                 ; place malloc heap between bss section and bottom of the stack
27    0000              
28    0000                 SECTION data_clib
29    0000                 SECTION data_alloc_malloc
30    0000              
31    0000                 PUBLIC __malloc_heap
32    0000              
33    0000                 EXTERN __BSS_END_tail
34    0000              
35    0000  00 00          __malloc_heap:              defw __BSS_END_tail
36    0002              
37    0002                 SECTION code_crt_init
38    0005              
39    0005  21 FF FF       ld hl,-1                    ; ensure sp == 0 is accepted
40    0008  39             add hl,sp                   ; hl = top of the stack
41    0009              
42    0009  11 00 00       ld de,__BSS_END_tail
43    000C              
44    000C  AF             xor a
45    000D  ED 52          sbc hl,de                   ; hl = space between top of stack and end of bss - 1
46    000F              
47    000F  DA 06 00       jp c, __Exit                ; if stack overlaps bss, this is a fatal error
48    0012              
49    0012  01 0E 02       ld bc,__crt_stack_size + 14 ; amount of space reserved by stack + minimum heap size - 1
50    0015  ED 42          sbc hl,bc                   ; hl = max heap size - 15
51    0017              
52    0017  DA 06 00       jp c, __Exit                ; if no room for heap, this is a fatal error
53    001A              
54    001A  01 0F 00       ld bc,15
55    001D  09             add hl,bc
56    001E              
57    001E  4D             ld c,l
58    001F  44             ld b,h                      ; bc = available heap size
59    0020              
60    0020  EB             ex de,hl                    ; hl = __BSS_END_tail = start of heap
61    0021              
62    0021                 EXTERN asm_heap_init
63    0021  CD 00 00       call asm_heap_init
64    0024              
65    0024              ENDIF
66    0024              
67    0024              IF __clib_malloc_heap_size > 14
68    0024              
69    0024                 ; create malloc heap in bss section
70    0024              
71    0024                 SECTION data_clib
72    0024                 SECTION data_alloc_malloc
73    0024              
74    0024                 PUBLIC __malloc_heap
75    0024              
76    0024                 __malloc_heap:              defw __malloc_block
77    0024              
78    0024                 SECTION bss_clib
79    0024                 SECTION bss_alloc_malloc
80    0024              
81    0024                 __malloc_block:             defs __clib_malloc_heap_size
82    0024              
83    0024                 SECTION code_crt_init
84    0024              
85    0024                 ld hl,__malloc_block
86    0024                 ld bc,__clib_malloc_heap_size
87    0024              
88    0024                 EXTERN asm_heap_init
89    0024                 call asm_heap_init
90    0024              
91    0024              ENDIF
92    0024              
93    0024                 ; create exit stack
94    0024              
95    0024                 SECTION bss_clib
96    0000                 SECTION bss_stdlib
97    0000              
98    0000                 PUBLIC __exit_stack
99    0000              
100   0000  00             __exit_stack:               defb 0
101   0001  00 00 00 00                                defs __exit_stack_size * 2
102   0005              
103   0005                 ; create quickexit stack
104   0005              
105   0005                 SECTION bss_clib
106   0000                 SECTION bss_stdlib
107   0005              
108   0005                 PUBLIC __quickexit_stack
109   0005              
110   0005  00             __quickexit_stack:          defb 0
111   0006                                             defs __quickexit_stack_size * 2
112   0006              
113   0006                 ; assign thread id
114   0006              
115   0006                 SECTION data_clib
116   0000                 SECTION data_threads
117   0000              
118   0000                 PUBLIC __thrd_id
119   0000              
120   0000  01             __thrd_id:                  defb 1
121   0001              
122   0001              ;; end library variables ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
123   0001              
686   0001              include "clib_target_variables.inc"
1     0001              
2     0001              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
3     0001              ;; target variables ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4     0001              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
5     0001              
6     0001              ;; end target variables ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
7     0001              
687   0001              
688   0001              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
689   0001              ;; CLIB STUBS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
690   0001              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
691   0001              
692   0001              include "../clib_stubs.inc"
1     0001              
2     0001                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
3     0001                 ;; unimplemented
4     0001                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
5     0001              
6     0001                 ; system()
7     0001              
8     0001                 PUBLIC __ch_system
9     0001              
10    0001                 EXTERN error_zc
11    0001              
12    0001                 defc __ch_system = error_zc
13    0001              
14    0001                 ; threads
15    0001                 ; these functions are preliminary only
16    0001              
17    0001                 PUBLIC __thread_context_switch
18    0001                 PUBLIC __thread_block_timeout
19    0001                 PUBLIC __thread_unblock
20    0001              
21    0001                 EXTERN l_ret
22    0001              
23    0001                 defc __thread_context_switch = l_ret
24    0001                 defc __thread_block_timeout  = l_ret
25    0001                 defc __thread_unblock        = l_ret
26    0001              
27    0001                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
28    0001                 ;; dynamically generated functions
29    0001                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
30    0001              
31    0001                 IF !DEFINED_CLIB_OPT_STDIO
32    0001                    defc DEFINED_CLIB_OPT_STDIO = 1
33    0001                    defc CLIB_OPT_STDIO = 0
34    0001                 ENDIF
35    0001              
36    0001                 defc __CLIB_OPT_STDIO = CLIB_OPT_STDIO
37    0001              
38    0001                 ; dynamic printf
39    0001              
40    0001                 IF DEFINED_CLIB_OPT_PRINTF
41    0001                    IF !DEFINED_CLIB_OPT_PRINTF_2
42    0001                       defc DEFINED_CLIB_OPT_PRINTF_2 = 1
43    0001                       defc CLIB_OPT_PRINTF_2 = 0
44    0001                    ENDIF
45    0001                 ENDIF
46    0001              
47    0001                 IF DEFINED_CLIB_OPT_PRINTF_2
48    0001                    IF !DEFINED_CLIB_OPT_PRINTF
49    0001                       defc DEFINED_CLIB_OPT_PRINTF = 1
50    0001                       defc CLIB_OPT_PRINTF = 0
51    0001                    ENDIF
52    0001                 ENDIF
53    0001              
54    0001                 IF DEFINED_CLIB_OPT_PRINTF
55    0001              
56    0001                    defc __CLIB_OPT_PRINTF = CLIB_OPT_PRINTF
57    0001                    defc __CLIB_OPT_PRINTF_2 = CLIB_OPT_PRINTF_2
58    0001              
59    0001                    IF __SDCC_IY
60    0001              
61    0001                       INCLUDE "../../stdio/z80/asm_vfprintf_unlocked_iy.asm"
62    0001              
63    0001                    ELSE
64    0001              
65    0001                       INCLUDE "../../stdio/z80/asm_vfprintf_unlocked.asm"
66    0001              
67    0001                    ENDIF
68    0001              
69    0001                 ENDIF
70    0001              
71    0001                 ; dynamic scanf
72    0001              
73    0001                 IF DEFINED_CLIB_OPT_SCANF
74    0001                    IF !DEFINED_CLIB_OPT_SCANF_2
75    0001                       defc DEFINED_CLIB_OPT_SCANF_2 = 1
76    0001                       defc CLIB_OPT_SCANF_2 = 0
77    0001                    ENDIF
78    0001                 ENDIF
79    0001              
80    0001                 IF DEFINED_CLIB_OPT_SCANF_2
81    0001                    IF !DEFINED_CLIB_OPT_SCANF
82    0001                       defc DEFINED_CLIB_OPT_SCANF = 1
83    0001                       defc CLIB_OPT_SCANF = 0
84    0001                    ENDIF
85    0001                 ENDIF
86    0001              
87    0001                 IF DEFINED_CLIB_OPT_SCANF
88    0001              
89    0001                    defc __CLIB_OPT_SCANF = CLIB_OPT_SCANF
90    0001                    defc __CLIB_OPT_SCANF_2 = CLIB_OPT_SCANF_2
91    0001              
92    0001                    IF __SDCC_IY
93    0001              
94    0001                       INCLUDE "../../stdio/z80/asm_vfscanf_unlocked_iy.asm"
95    0001              
96    0001                    ELSE
97    0001              
98    0001                       INCLUDE "../../stdio/z80/asm_vfscanf_unlocked.asm"
99    0001              
100   0001                    ENDIF
101   0001              
102   0001                 ENDIF
103   0001              
693   0001              
47    0001              
48    0001              ENDIF
49    0001              
